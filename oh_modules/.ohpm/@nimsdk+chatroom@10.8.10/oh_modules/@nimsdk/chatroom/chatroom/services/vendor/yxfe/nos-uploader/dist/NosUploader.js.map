{"version":3,"file":"NosUploader.js","mappings":"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","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/./src/Config.ts","webpack://[name]/./src/fileState.ts","webpack://[name]/./src/util.ts","webpack://[name]/./src/getOffset.ts","webpack://[name]/./src/uploadTrunk.ts","webpack://[name]/./src/Task.ts","webpack://[name]/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NosUploader\"] = factory();\n\telse\n\t\troot[\"NosUploader\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","class Config {\n    public constructor(opts) {\n        this.directUploadAddr = 'https://wanproxy-web.127.net';\n        this.retryCount = 1;\n        this.trunkSize = 4 * 1024 * 1024;\n        this.trunkUploadTimeout = 50000;\n        this.getOffsetTimeout = 10000;\n        this.version = '1.0';\n        this.enableCache = true;\n        this.logger = console;\n        this.onError = function (err) {\n        };\n        this.onProgress = function (progress) {\n        };\n        this.onUploadProgress = function (progressEvent) {\n        };\n        this.onComplete = function (uploadInfo) {\n        };\n        for (let key in opts) {\n            this[key] = opts[key];\n        }\n    }\n}\nexport default Config;\n","import NosUploader from \".\";\nlet storage = window.localStorage;\nif (!window.localStorage ||\n    typeof window.localStorage.getItem !== 'function' ||\n    typeof window.localStorage.setItem !== 'function' ||\n    typeof window.localStorage.removeItem !== 'function') {\n    storage = {\n        privateObj: {},\n        setItem: function (key, value) {\n            storage.privateObj[key] = value;\n        },\n        getItem: function (key) {\n            return storage.privateObj[key];\n        },\n        removeItem: function (key) {\n            delete storage.privateObj[key];\n        },\n        getKeys: function () {\n            return Object.keys(storage.privateObj);\n        }\n    };\n}\nconst fileState = {\n    getFileKey(file) {\n        const fileSize = file.size.toString();\n        const fileLastModifiedAt = file.lastModified.toString();\n        return '_NosUploader_' + file.name + fileSize.slice(fileSize.length - 5) + fileLastModifiedAt.slice(fileLastModifiedAt.length - 5);\n    },\n    getFileInfo(key) {\n        const infoString = storage.getItem(key);\n        if (!infoString) {\n            return null;\n        }\n        else {\n            try {\n                return JSON.parse(infoString);\n            }\n            catch (err) {\n                /**\n                 * 可能clearCache使用了非fileKey来获取fileInfo\n                 */\n                return null;\n            }\n        }\n    },\n    initFile(param, file, enableCache) {\n        fileState.clearExpiredInfo();\n        const fileKey = this.getFileKey(file);\n        const fileInfo = {\n            ctx: (param.ctx !== undefined) ? param.ctx : '',\n            bucket: param.bucketName,\n            obj: param.objectName,\n            token: param.token,\n            modifyAt: Date.now(),\n            end: false\n        };\n        if (param.payload) {\n            fileInfo.payload = param.payload;\n        }\n        /**\n         * 初始化\n         */\n        if (enableCache) {\n            storage.setItem(fileKey, JSON.stringify(fileInfo));\n        }\n        return fileKey;\n    },\n    setUploadContext(fileKey, context, enableCache) {\n        const fileInfo = this.getFileInfo(fileKey);\n        if (fileInfo) {\n            fileInfo.ctx = context;\n            if (enableCache) {\n                storage.setItem(fileKey, JSON.stringify(fileInfo));\n            }\n        }\n    },\n    setComplete(fileKey, enableCache) {\n        const fileInfo = this.getFileInfo(fileKey);\n        if (fileInfo) {\n            fileInfo.modifyAt = Date.now();\n            fileInfo.end = true;\n            if (enableCache) {\n                storage.setItem(fileKey, JSON.stringify(fileInfo));\n            }\n        }\n    },\n    getUploadContext(fileKey) {\n        const fileInfo = this.getFileInfo(fileKey);\n        return fileInfo ? fileInfo.ctx : '';\n    },\n    removeFileInfo(fileKey) {\n        if (fileKey.indexOf('_NosUploader_') === 0) {\n            /**\n             * 属于 NosUploader 的数据才会被删除\n             */\n            storage.removeItem(fileKey);\n        }\n    },\n    /**\n     * 清理超出容量限制的存储，或者超出时间限制的存储\n     */\n    clearExpiredInfo() {\n        const keys = typeof storage.getKeys === 'function' ? storage.getKeys() : Object.keys(storage);\n        const now = Date.now();\n        let tempArray = [];\n        /**\n         * 删除超时的文件记录\n         */\n        for (let key of keys) {\n            if (key.indexOf('_NosUploader_') !== 0) {\n                /**\n                 * 不属于 NosUploader 的数据不用处理\n                 */\n                continue;\n            }\n            const info = fileState.getFileInfo(key);\n            if (info === null || (now - info.modifyAt > NosUploader.expireTime)) {\n                storage.removeItem(key);\n            }\n            else {\n                tempArray.push({\n                    fileInfo: info,\n                    key\n                });\n            }\n        }\n        /**\n         * 超出了最大存储设置，删除最老上传的文件记录\n         */\n        if (tempArray.length > NosUploader.maxFileCache) {\n            const sortedArray = tempArray.sort((a, b) => {\n                return b.fileInfo.modifyAt - a.fileInfo.modifyAt;\n            });\n            const obsoleteArray = sortedArray.slice(NosUploader.maxFileCache);\n            for (let entry of obsoleteArray) {\n                /**\n                 * 属于 NosUploader 的数据才需要被删除\n                 */\n                if (entry.key.indexOf('_NosUploader_') === 0) {\n                    storage.removeItem(entry.key);\n                }\n            }\n        }\n    }\n};\nexport default fileState;\n","export class CustomError extends Error {\n    public constructor(message, code) {\n        super('NosUploadError:' + message);\n        this.errCode = code;\n        this.errMsg = message;\n    }\n}\n","import fileState from \"./fileState\";\nimport { CustomError } from \"./util\";\nfunction getOffset(task, retryRemain, callback) {\n    if (task.uploadState !== 'uploading') {\n        return;\n    }\n    const { config, param } = task;\n    const context = fileState.getUploadContext(task.fileKey);\n    if (!context) {\n        return callback(0);\n    }\n    const xhr = new XMLHttpRequest();\n    const url = config.directUploadAddr\n        + `/${param.bucketName}`\n        + `/${encodeURIComponent(param.objectName)}`\n        + '?uploadContext'\n        + `&context=${context}`\n        + `&version=${config.version}`;\n    xhr.onreadystatechange = function () {\n        var _a;\n        if (task.uploadState === 'abort') {\n            return;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        let result;\n        try {\n            result = JSON.parse(xhr.responseText);\n        }\n        catch (e) {\n            result = {\n                errMsg: 'JsonParseError in getOffset',\n                errCode: 500\n            };\n        }\n        if (xhr.status === 200) {\n            if (result.errCode) {\n                task.config.onError(new CustomError(result.errMsg, result.errCode));\n            }\n            else {\n                callback(result.offset);\n            }\n        }\n        else if (xhr.status.toString().match(/^5/)) {\n            getOffset(task, retryRemain - 1, callback);\n        }\n        else {\n            if (retryRemain > 0) {\n                /**\n                 * 如果还有重试次数，则隔5s后重试。这时可能网络环境已经发生了变化\n                 */\n                if (typeof ((_a = config.logger) === null || _a === void 0 ? void 0 : _a.error) === 'function') {\n                    config.logger.error(`getOffset(${url}) error. retry after 3 seconds. ${new Date().toTimeString()}`);\n                }\n                setTimeout(() => {\n                    getOffset(task, retryRemain - 1, callback);\n                }, 3500);\n            }\n            else {\n                fileState.removeFileInfo(task.fileKey);\n                if (xhr.status) {\n                    config.onError(new CustomError(`getOffset(${url}) error: ${xhr.status} ${xhr.statusText}`));\n                }\n                else {\n                    config.onError(new CustomError(`getOffset(${url}) error. no Error Code`));\n                }\n            }\n        }\n    };\n    xhr.open('get', url);\n    xhr.setRequestHeader('x-nos-token', param.token);\n    xhr.timeout = config.getOffsetTimeout;\n    xhr.send();\n}\nexport default getOffset;\n","import fileState from './fileState';\nimport { CustomError } from './util';\n/**\n * 上传分片\n * @method uploadTrunk\n * @param  {Object}   param     AJAX参数\n *  \tparam中的属性有：\n * \t\tserveIp {String} IP地址\n * \t\tbucketName {String} 桶名\n * \t\tobjectName {String} 对象名\n * \t\ttoken {String} 上传凭证\n * @param  {Object}   trunkData 分片数据\n * \t\ttrunkData属性有：\n * \t\tfile {File} File对象\n *      fileKey {String} 文件名和文件大小的组合值\n *      offset {long} 当前分片在整个对象中的起始偏移量\n *      trunkSize {long} 分片大小\n *      trunkEnd {long} 分片结束位置\n *      context: {String} 上传上下文\n * @param  {Function} callback  文件（非分片）上传成功回调函数\n * \t\t回调函数参数：\n * \t\ttrunkData {Object} 分片数据\n * @return {void}\n */\nfunction uploadTrunk(task, offset, retryRemain, callback) {\n    if (task.uploadState !== 'uploading') {\n        return;\n    }\n    const { param, config } = task;\n    const blobSlice = File.prototype.slice;\n    const context = param.ctx !== undefined ? param.ctx : '';\n    const isComplete = (offset + config.trunkSize) > task.file.size;\n    const trunkEnd = isComplete ? task.file.size : (offset + config.trunkSize);\n    const xhr = new XMLHttpRequest();\n    const url = config.directUploadAddr\n        + `/${param.bucketName}`\n        + `/${encodeURIComponent(param.objectName)}`;\n    xhr.upload.onprogress = function (e) {\n        if (task.uploadState === 'abort') {\n            return;\n        }\n        var progress = 0;\n        if (e.lengthComputable) {\n            progress = (offset + e.loaded) / task.file.size;\n            config.onProgress(progress);\n            config.onUploadProgress({\n                loaded: e.loaded,\n                total: task.file.size,\n                percentage: progress,\n                percentageText: (progress * 100).toFixed(2) + '%'\n            });\n        }\n        else {\n            config.onError(new CustomError('browser does not support query upload progress'));\n        }\n    };\n    xhr.onreadystatechange = function () {\n        var _a, _b;\n        if (task.uploadState === 'abort') {\n            return;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        let result;\n        try {\n            result = JSON.parse(xhr.responseText);\n        }\n        catch (e) {\n            if (typeof ((_a = config.logger) === null || _a === void 0 ? void 0 : _a.error) === 'function') {\n                config.logger.error('JsonParseError in uploadTrunk', e);\n            }\n            result = {\n                errMsg: 'JsonParseError in uploadTrunk'\n            };\n        }\n        if (xhr.status === 200) {\n            task.setContext(result.context);\n            if (isComplete) {\n                callback();\n                task.setComplete();\n            }\n            else {\n                uploadTrunk(task, result.offset, config.retryCount, callback);\n            }\n        }\n        else if (xhr.status.toString().match(/^5/)) {\n            //服务器出错重试\n            if (retryRemain > 0) { //同一个边缘节点重试两次\n                uploadTrunk(task, offset, retryRemain - 1, callback);\n            }\n            else { //重试完输出错误信息\n                fileState.removeFileInfo(task.fileKey);\n                config.onError(new CustomError(result.errMsg, result.errCode));\n            }\n        }\n        else {\n            if (retryRemain > 0) {\n                /**\n                 * 如果还有重试次数，则隔5s后重试。这时可能网络环境已经发生了变化\n                 */\n                if (typeof ((_b = config.logger) === null || _b === void 0 ? void 0 : _b.error) === 'function') {\n                    config.logger.error(`uploadTrunk(${url}) error. retry after 3 seconds. ${new Date().toTimeString()}`);\n                }\n                setTimeout(() => {\n                    uploadTrunk(task, offset, retryRemain - 1, callback);\n                }, 3500);\n            }\n            else {\n                fileState.removeFileInfo(task.fileKey);\n                if (xhr.status) {\n                    config.onError(new CustomError(`uploadTrunk(${url}) error: ${xhr.status} ${xhr.statusText}`));\n                }\n                else {\n                    config.onError(new CustomError(`uploadTrunk(${url}) error. no Error Code. Please check your network`));\n                }\n            }\n        }\n    };\n    xhr.open('post', url\n        + `?offset=${offset}`\n        + `&complete=${isComplete}`\n        + `&context=${context}`\n        + `&version=${config.version}`);\n    xhr.setRequestHeader('x-nos-token', param.token);\n    if (param.md5) {\n        xhr.setRequestHeader('content-md5', param.md5);\n    }\n    if (task.file.type) {\n        xhr.setRequestHeader('content-type', task.file.type);\n    }\n    xhr.timeout = config.trunkUploadTimeout;\n    // 修复支付宝环境 webview 中上传不成功问题\n    // 本质上是支付宝 webview 的 bug，猜测是从本地读文件失败导致 post 请求发不上去\n    // SDK 做了一些绕过的策略，先把本地文件通过 FileReader 读到内存，再从内存中的数据 转 blob 提交给表单。\n    // 需要小心 FileReader 的兼容性，IE9 它毕竟是不支持的\n    // 详见 jira：http://jira.netease.com/browse/IM-2500\n    if (typeof FileReader !== \"undefined\") {\n        var reader = new FileReader();\n        reader.addEventListener('load', function (event) {\n            var _a;\n            if ((_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.result) {\n                // xhr.send(new Blob([event.target.result]));\n                /**\n                 * 修复在粤政易得webview中上传时，发送数据content-length为0的问题\n                 * 问题原因是粤政易的webview上传blob时，发送数据会为空\n                 * 若改为发送File, 发送的数据会回退为multipart/form-data, 且没有正确的设置content-type，这导致nos无法正确解析上传的数据\n                 *\n                 * 改为send ArrayBuffer之后，现在能够正确上传\n                 */\n                xhr.send(event.target.result);\n                return;\n            }\n            config.onError(new CustomError('Read ArrayBuffer failed'));\n        });\n        // 修复 IM-4094，磁盘删除文件后 fileReader 读取失败没有反馈。\n        reader.addEventListener('error', function (event) {\n            // uploadOptions.onerror(event.target.error)\n            const error = event.target.error;\n            config.onError(new CustomError(`Read ArrayBuffer error. ${error.toString()}`, error.code));\n        });\n        reader.readAsArrayBuffer(blobSlice.call(task.file, offset, trunkEnd));\n    }\n    else {\n        xhr.send(blobSlice.call(task.file, offset, trunkEnd));\n    }\n}\nexport default uploadTrunk;\n","import fileState from \"./fileState\";\nimport getOffset from \"./getOffset\";\nimport uploadTrunk from \"./uploadTrunk\";\nimport { CustomError } from \"./util\";\nclass Task {\n    public constructor(file, param, config) {\n        this.uploadState = 'paused';\n        this.config = config;\n        this.file = file;\n        this.param = param;\n        this.fileKey = fileState.initFile(param, file, this.config.enableCache);\n        this.resume();\n    }\n    resume() {\n        if (this.uploadState === 'uploading') {\n            return;\n        }\n        this.setUploadState('uploading');\n        const config = this.config;\n        getOffset(this, config.retryCount, (offset) => {\n            uploadTrunk(this, offset, config.retryCount, () => {\n                this.setUploadState('ended');\n                if (typeof config.onComplete === 'function') {\n                    config.onComplete(this.param);\n                }\n            });\n        });\n    }\n    pause() {\n        this.setUploadState('paused');\n    }\n    abort() {\n        if (this.uploadState !== 'ended' && this.uploadState !== 'abort') {\n            this.setUploadState('abort');\n            fileState.removeFileInfo(this.fileKey);\n            this.config.onError(new CustomError(`Upload Aborted`, 10499));\n        }\n    }\n    setUploadState(state) {\n        if (state !== this.uploadState) {\n            this.uploadState = state;\n        }\n    }\n    setContext(context) {\n        fileState.setUploadContext(this.fileKey, context, this.config.enableCache);\n        this.param.ctx = context;\n    }\n    setComplete() {\n        fileState.setComplete(this.fileKey, this.config.enableCache);\n        this.setUploadState('ended');\n    }\n}\nexport default Task;\n","import Config from \"./Config\";\nimport fileState from \"./fileState\";\nimport Task from \"./Task\";\nconst NosUploader = {\n    /**\n     * 每次创建新的文件上传任务时，会检查是否cache过多，或者上传过期，然后删除不再符合要求的文件信息\n     */\n    /**\n     * 最多存储默认6个文件上传信息\n     */\n    maxFileCache: 6,\n    /**\n     * 默认1天后过期\n     */\n    expireTime: 1000 * 60 * 60 * 24,\n    getFileUploadInformation: (file) => {\n        const fileKey = fileState.getFileKey(file);\n        const fileInfo = fileState.getFileInfo(fileKey);\n        if (fileInfo === null) {\n            return null;\n        }\n        else if (Date.now() - fileInfo.modifyAt > NosUploader.expireTime) {\n            fileState.removeFileInfo(fileKey);\n            return null;\n        }\n        else {\n            return {\n                uploadInfo: Object.assign({ bucketName: fileInfo.bucket, objectName: fileInfo.obj, token: fileInfo.token, ctx: fileInfo.ctx }, (fileInfo.payload ? {\n                    payload: fileInfo.payload\n                } : {})),\n                complete: fileInfo.end\n            };\n        }\n    },\n    setMaxFileCache: (val) => {\n        NosUploader.maxFileCache = val;\n    },\n    setExpireTime: (ms) => {\n        NosUploader.expireTime = ms;\n    },\n    printCaches: () => {\n        const keys = Object.keys(localStorage);\n        for (let key of keys) {\n            const fileInfo = fileState.getFileInfo(key);\n            if (fileInfo) {\n                console.log(fileInfo, 'modifiedAt', new Date(fileInfo.modifyAt).toTimeString());\n            }\n        }\n    },\n    createConfig: (params) => {\n        return new Config(params);\n    },\n    createTask: (file, param, config) => {\n        return new Task(file, param, config);\n    }\n};\nexport default NosUploader;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","opts","this","directUploadAddr","retryCount","trunkSize","trunkUploadTimeout","getOffsetTimeout","version","enableCache","logger","console","onError","err","onProgress","progress","onUploadProgress","progressEvent","onComplete","uploadInfo","storage","window","localStorage","getItem","setItem","removeItem","privateObj","value","getKeys","keys","fileState","getFileKey","file","fileSize","size","toString","fileLastModifiedAt","lastModified","name","slice","length","getFileInfo","infoString","JSON","parse","initFile","param","clearExpiredInfo","fileKey","fileInfo","ctx","undefined","bucket","bucketName","objectName","token","modifyAt","Date","now","end","payload","stringify","setUploadContext","context","setComplete","getUploadContext","removeFileInfo","indexOf","tempArray","info","NosUploader","push","sort","a","b","entry","CustomError","message","code","errCode","errMsg","Error","getOffset","task","retryRemain","callback","uploadState","config","xhr","XMLHttpRequest","url","encodeURIComponent","onreadystatechange","_a","readyState","result","responseText","e","status","offset","match","error","toTimeString","setTimeout","statusText","open","setRequestHeader","timeout","send","uploadTrunk","blobSlice","File","isComplete","trunkEnd","upload","onprogress","lengthComputable","loaded","total","percentage","percentageText","toFixed","_b","setContext","md5","type","FileReader","reader","addEventListener","event","target","readAsArrayBuffer","Task","resume","setUploadState","state","maxFileCache","expireTime","getFileUploadInformation","assign","complete","setMaxFileCache","val","setExpireTime","ms","printCaches","log","createConfig","params","Config","createTask"],"sourceRoot":""}