import { ColumnInfo, ColumnType, RdbPredicates, RdbTableImpl, V2NIMErrorImpl, V2NIMErrorMap } from '@nimsdk/base'; import { registerAspect } from './Aspect'; export const APPLICATION_TABLE = { tableName: 'application_table', columns: [ 'applicant', 'recipient', 'operator', 'timestamp', 'postscript', 'status', 'read' ] }; export const ApplicationColumns = [ new ColumnInfo('applicant', ColumnType.TEXT, -1, false), new ColumnInfo('recipient', ColumnType.TEXT, -1, false), new ColumnInfo('operator', ColumnType.TEXT, -1, false), new ColumnInfo('timestamp', ColumnType.INTEGER, -1, false), new ColumnInfo('postscript', ColumnType.TEXT, -1, true), new ColumnInfo('status', ColumnType.INTEGER, -1, false), new ColumnInfo('read', ColumnType.INTEGER, -1, false) ]; const FriendNotificationTableName = APPLICATION_TABLE.tableName; const TAG = '[FriendNotificationTable]'; export class FriendNotificationTable extends RdbTableImpl { constructor(i12, j12) { super(i12, FriendNotificationTableName); this.logger = j12.logger; registerAspect(FriendNotificationTableName, FriendNotificationTable, j12); } async createTable() { try { this.createTableError = null; const h12 = { tableName: FriendNotificationTableName, indexName: 'operator_index', columns: ['operator'] }; await Promise.all([ await this.rdbStoreManager.createTable(FriendNotificationTableName, false, ApplicationColumns), await this.rdbStoreManager.createTableIndex(h12) ]); } catch (g12) { console.info(`create table data: friendNotificationTable ${JSON.stringify(g12)}`); this.createTableError = g12; } } async addApplication(c12) { try { await this.ensureCreateTable(); this.logger.info(TAG, 'addApplication', c12); const e12 = await this.isSavedApplication(c12); if (!e12) { const f12 = generateBucket(c12); await this.rdbStoreManager.insert(this.tableName, [f12]); } } catch (d12) { this.logger.error(TAG, 'addApplication', c12, d12); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `addApplication ${c12}`, rawError: d12 } }); } } async updateStatus(w11, x11, y11) { try { await this.ensureCreateTable(); this.logger.info(TAG, 'updateStatus', w11, x11, y11); const a12 = {}; a12['status'] = w11; a12['operator'] = y11; a12['read'] = 1; const b12 = new RdbPredicates(FriendNotificationTableName) .equalTo('applicant', x11) .and() .equalTo('status', 0); await this.rdbStoreManager.update(a12, b12); } catch (z11) { this.logger.error(TAG, 'updateStatus', w11, x11, y11, z11); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `updateStatus ${w11}`, rawError: z11 } }); } } async setAddApplicationRead() { try { await this.ensureCreateTable(); this.logger.info(TAG, 'setAddApplicationRead'); const u11 = {}; u11['read'] = 1; const v11 = new RdbPredicates(FriendNotificationTableName).equalTo('read', 0); await this.rdbStoreManager.update(u11, v11); } catch (t11) { this.logger.error(TAG, 'setAddApplicationRead', t11); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `setAddApplicationRead`, rawError: t11 } }); } } async queryApplicationList(l11, m11, n11) { try { await this.ensureCreateTable(); this.logger.info(TAG, 'queryApplicationList', l11, m11, n11); const p11 = new RdbPredicates(FriendNotificationTableName) .in('status', l11) .orderByDesc('timestamp') .offsetAs(n11) .limitAs(m11); const q11 = await this.rdbStoreManager.query(p11); let r11 = []; q11.map(s11 => { r11.push(getObjectByValue(s11)); }); return r11; } catch (o11) { this.logger.error(TAG, 'queryApplicationList', l11, m11, n11, o11); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `queryApplicationList ${l11}`, rawError: o11 } }); } } async queryApplicationUnreadCount() { try { await this.ensureCreateTable(); this.logger.info(TAG, 'queryApplicationUnreadCount'); const g11 = new RdbPredicates(FriendNotificationTableName) .equalTo('read', 0); const h11 = await this.rdbStoreManager.query(g11); let i11 = new Map(); h11.map(j11 => { const k11 = getObjectByValue(j11); i11.set(k11.operatorAccountId, 1); }); return i11.size; } catch (f11) { this.logger.error(TAG, 'queryApplicationUnreadCount', f11); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `queryApplicationUnreadCount`, rawError: f11 } }); } } async clearAllAddApplication() { try { await this.ensureCreateTable(); this.logger.info(TAG, 'clearApplicationList'); await this.rdbStoreManager.clearTable(FriendNotificationTableName); } catch (e11) { this.logger.error(TAG, 'clearApplicationList', e11); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `clearApplicationList`, rawError: e11 } }); } } async deleteAddApplication(z10, a11, b11) { try { await this.ensureCreateTable(); this.logger.info(TAG, 'deleteAddApplication'); if (typeof z10 !== 'string' || z10.length <= 0) { this.logger.warn(TAG, 'deleteAddApplication applicantAccountId', z10); return; } if (typeof a11 !== 'string' || a11.length <= 0) { this.logger.warn(TAG, 'deleteAddApplication recipientAccountId', a11); return; } if (typeof b11 !== 'number' || b11 <= 0) { this.logger.warn(TAG, 'deleteAddApplication timestamp', b11); return; } const d11 = new RdbPredicates(FriendNotificationTableName) .equalTo('applicant', z10) .and() .equalTo('recipient', a11) .and() .equalTo('timestamp', b11); await this.rdbStoreManager.delete(d11); } catch (c11) { this.logger.error(TAG, 'deleteAddApplication', c11); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `deleteAddApplication`, rawError: c11 } }); } } async isSavedApplication(v10) { try { await this.ensureCreateTable(); this.logger.info(TAG, 'isSavedApplication', v10); const x10 = new RdbPredicates(FriendNotificationTableName) .equalTo('applicant', v10.applicantAccountId) .and() .equalTo('recipient', v10.recipientAccountId) .and() .equalTo('operator', v10.operatorAccountId) .and() .equalTo('timestamp', v10.timestamp) .and() .equalTo('postscript', v10.postscript) .and() .equalTo('status', v10.status) .and() .equalTo('read', v10.read); const y10 = await this.rdbStoreManager.query(x10); return y10.length > 0; } catch (w10) { this.logger.error(TAG, 'isSavedApplication', v10, w10); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `queryApplicationList ${v10}`, rawError: w10 } }); } } async updateApplication(r10) { try { await this.ensureCreateTable(); this.logger.info(TAG, 'updateApplication', r10); const t10 = generateBucket(r10); const u10 = new RdbPredicates(FriendNotificationTableName) .equalTo('applicant', r10.applicantAccountId) .and() .equalTo('recipient', r10.recipientAccountId) .and() .equalTo('operator', r10.operatorAccountId) .and(); await this.rdbStoreManager.update(t10, u10); } catch (s10) { this.logger.error(TAG, 'updateApplication', r10, s10); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `updateStatus ${r10}`, rawError: s10 } }); } } } function getObjectBySet(p10) { const q10 = { applicantAccountId: p10.getString(p10.getColumnIndex('applicant')), recipientAccountId: p10.getString(p10.getColumnIndex('recipient')), operatorAccountId: p10.getString(p10.getColumnIndex('operator')), status: p10.getLong(p10.getColumnIndex('status')), postscript: p10.getString(p10.getColumnIndex('postscript')), timestamp: p10.getLong(p10.getColumnIndex('timestamp')), read: p10.getLong(p10.getColumnIndex('read')) > 0 ? true : false }; return q10; } function getObjectByValue(n10) { const o10 = { applicantAccountId: n10.applicant, recipientAccountId: n10.recipient, operatorAccountId: n10.operator, status: n10.status, postscript: n10.postscript, timestamp: n10.timestamp, read: n10.read > 0 ? true : false }; return o10; } function generateBucket(k10) { const l10 = {}; APPLICATION_TABLE.columns.forEach((m10) => { switch (m10) { case 'applicant': l10[m10] = k10.applicantAccountId; break; case 'recipient': l10[m10] = k10.recipientAccountId; break; case 'operator': l10[m10] = k10.operatorAccountId; break; case 'postscript': l10[m10] = k10.postscript ?? ''; break; case 'status': l10[m10] = k10.status; break; case 'timestamp': l10[m10] = k10.timestamp; break; case 'read': l10[m10] = k10.read; break; default: break; } }); return l10; } 