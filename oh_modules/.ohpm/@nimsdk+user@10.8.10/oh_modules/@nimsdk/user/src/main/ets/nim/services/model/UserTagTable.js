import { ColumnInfo, ColumnType, RdbPredicates, RdbTableImpl, V2NIMErrorImpl, V2NIMErrorMap } from '@nimsdk/base'; import { registerAspect } from './Aspect'; var COL_NAME; (function (d3) { d3["ACCOUNT"] = "account"; d3["MUTE"] = "mute"; d3["BLACK"] = "black"; d3["CREATE_TIME"] = "create_time"; d3["UPDATE_TIME"] = "update_time"; })(COL_NAME || (COL_NAME = {})); const t2 = 'user_tag_account_index'; export const USER_TAG_TABLE = { tableName: 'user_tag_table', columns: [ COL_NAME.ACCOUNT, COL_NAME.MUTE, COL_NAME.BLACK, COL_NAME.CREATE_TIME, COL_NAME.UPDATE_TIME ] }; export const UserTagColumns = [ new ColumnInfo(COL_NAME.ACCOUNT, ColumnType.TEXT, -1, false), new ColumnInfo(COL_NAME.MUTE, ColumnType.INTEGER, -1, false), new ColumnInfo(COL_NAME.BLACK, ColumnType.INTEGER, -1, false), new ColumnInfo(COL_NAME.CREATE_TIME, ColumnType.INTEGER, -1, false), new ColumnInfo(COL_NAME.UPDATE_TIME, ColumnType.INTEGER, -1, false) ]; const b1 = '[UserTagTable]'; export class UserTagTable extends RdbTableImpl { constructor(b3, c3) { super(b3); this.logger = c3.logger; registerAspect(USER_TAG_TABLE.tableName, UserTagTable, c3); } async createTable() { try { this.createTableError = null; const a3 = { tableName: USER_TAG_TABLE.tableName, indexName: t2, columns: [COL_NAME.ACCOUNT] }; await Promise.all([ await this.rdbStoreManager.createTable(USER_TAG_TABLE.tableName, false, UserTagColumns), await this.rdbStoreManager.createTableUniqueIndex(a3) ]); } catch (e) { console.info(`create table data: userTag ${JSON.stringify(e)}`); this.createTableError = e; } } async addBlock(account) { try { if (typeof account === 'undefined' || account.length <= 0) { this.logger.info(b1, `addBlock illegal account: ${account}`); return; } await this.ensureCreateTable(); this.logger.info(b1, 'addBlock', account); const predicates = new RdbPredicates(USER_TAG_TABLE.tableName).equalTo(COL_NAME.ACCOUNT, account); const values = await this.rdbStoreManager.query(predicates); if (values.length > 0) { const valueBucket = {}; valueBucket[COL_NAME.BLACK] = true; await this.rdbStoreManager.update(valueBucket, predicates); } else { const z2 = q2(account, true); await this.rdbStoreManager.insertOrReplace(USER_TAG_TABLE.tableName, [z2]); } } catch (e) { this.logger.error(b1, 'addBlock', account, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `addBlock ${account}`, rawError: e } }); } } async removeBlock(account) { try { if (typeof account === 'undefined' || account.length <= 0) { this.logger.info(b1, `removeBlock illegal account: ${account}`); return; } await this.ensureCreateTable(); this.logger.info(b1, 'removeBlock', account); const predicates = new RdbPredicates(USER_TAG_TABLE.tableName).equalTo(COL_NAME.ACCOUNT, account); const values = await this.rdbStoreManager.query(predicates); if (values.length > 0) { this.logger.info(b1, 'removeBlock update', account); const valueBucket = {}; valueBucket[COL_NAME.BLACK] = false; await this.rdbStoreManager.update(valueBucket, predicates); } else { this.logger.info(b1, 'removeBlock insert', account); const w2 = q2(account, false); await this.rdbStoreManager.insertOrReplace(USER_TAG_TABLE.tableName, [w2]); } } catch (e) { this.logger.error(b1, 'removeBlock', account, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `removeBlock ${account}`, rawError: e } }); } } async getBlockList() { try { await this.ensureCreateTable(); this.logger.info(b1, 'getBlockList'); const predicates = new RdbPredicates(USER_TAG_TABLE.tableName).equalTo(COL_NAME.BLACK, 1); const values = await this.rdbStoreManager.query(predicates); const result = []; values.map(value => { const account = value.account; result.push(account); }); return result; } catch (e) { this.logger.error(b1, 'getBlockList', e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: 'getBlockList', rawError: e } }); } } async setAccountMuteMode(accountId, u2) { try { if (typeof accountId === 'undefined' || accountId.length <= 0) { this.logger.info(b1, `addMute illegal account: ${accountId}`); return; } await this.ensureCreateTable(); this.logger.info(b1, 'setAccountMuteMode', accountId, u2); const predicates = new RdbPredicates(USER_TAG_TABLE.tableName).equalTo(COL_NAME.ACCOUNT, accountId); const values = await this.rdbStoreManager.query(predicates); if (values.length > 0) { this.logger.info(b1, 'addMute update', accountId); const valueBucket = {}; valueBucket[COL_NAME.MUTE] = u2; await this.rdbStoreManager.update(valueBucket, predicates); } else { this.logger.info(b1, 'addMute insert', accountId); const v2 = s2(accountId, u2); await this.rdbStoreManager.insertOrReplace(USER_TAG_TABLE.tableName, [v2]); } } catch (e) { this.logger.error(b1, 'addMute', accountId, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `addMute ${accountId}`, rawError: e } }); } } async getMuteList() { try { await this.ensureCreateTable(); this.logger.info(b1, 'getMuteList'); const predicates = new RdbPredicates(USER_TAG_TABLE.tableName).equalTo(COL_NAME.MUTE, 1); const values = await this.rdbStoreManager.query(predicates); const result = []; values.map(value => { const account = value.account; result.push(account); }); return result; } catch (e) { this.logger.error(b1, 'getMuteList', e); return []; } } } function q2(account, black) { let valueBucket = {}; USER_TAG_TABLE.columns.forEach((item) => { switch (item) { case COL_NAME.ACCOUNT: valueBucket[item] = account; break; case COL_NAME.MUTE: valueBucket[item] = 0; break; case COL_NAME.BLACK: valueBucket[item] = black ? 1 : 0; break; case COL_NAME.CREATE_TIME: valueBucket[item] = 0; break; case COL_NAME.UPDATE_TIME: valueBucket[item] = 0; break; default: break; } }); return valueBucket; } function s2(account, mute) { let valueBucket = {}; USER_TAG_TABLE.columns.forEach((item) => { switch (item) { case COL_NAME.ACCOUNT: valueBucket[item] = account; break; case COL_NAME.MUTE: valueBucket[item] = mute; break; case COL_NAME.BLACK: valueBucket[item] = 0; break; case COL_NAME.CREATE_TIME: valueBucket[item] = 0; break; case COL_NAME.UPDATE_TIME: valueBucket[item] = 0; break; default: break; } }); return valueBucket; } 