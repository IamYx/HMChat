import { ColumnInfo, ColumnType, RdbPredicates, RdbTableImpl, V2NIMErrorImpl, V2NIMErrorMap } from '@nimsdk/base'; import { registerAspect } from './Aspect'; import { V2NIMUserImpl } from './V2NIMUserImpl'; export var COL_NAME; (function (p1) { p1["ACCOUNT"] = "account"; p1["NAME"] = "name"; p1["AVATAR"] = "avatar"; p1["SIGN"] = "sign"; p1["GENDER"] = "gender"; p1["EMAIL"] = "email"; p1["BIRTHDAY"] = "birthday"; p1["MOBILE"] = "mobile"; p1["EXTENSION"] = "extension"; p1["UPDATE_TIME"] = "update_time"; p1["CREATE_TIME"] = "create_time"; })(COL_NAME || (COL_NAME = {})); ; const o = 'info_account_index'; const t = 'info_update_time_index'; const u = 'info_name_index'; const a1 = 'info_name_index'; export const USER_INFO_TABLE = { tableName: 'user_info_table', columns: [ COL_NAME.ACCOUNT, COL_NAME.NAME, COL_NAME.AVATAR, COL_NAME.SIGN, COL_NAME.GENDER, COL_NAME.EMAIL, COL_NAME.BIRTHDAY, COL_NAME.MOBILE, COL_NAME.EXTENSION, COL_NAME.CREATE_TIME, COL_NAME.UPDATE_TIME ] }; export const UserInfoColumns = [ new ColumnInfo(COL_NAME.ACCOUNT, ColumnType.TEXT, -1, false), new ColumnInfo(COL_NAME.NAME, ColumnType.TEXT, -1, false), new ColumnInfo(COL_NAME.AVATAR, ColumnType.TEXT, -1, true), new ColumnInfo(COL_NAME.SIGN, ColumnType.TEXT, -1, true), new ColumnInfo(COL_NAME.GENDER, ColumnType.INTEGER, -1, true), new ColumnInfo(COL_NAME.EMAIL, ColumnType.TEXT, -1, true), new ColumnInfo(COL_NAME.BIRTHDAY, ColumnType.TEXT, -1, true), new ColumnInfo(COL_NAME.MOBILE, ColumnType.TEXT, -1, true), new ColumnInfo(COL_NAME.EXTENSION, ColumnType.TEXT, 1024, true), new ColumnInfo(COL_NAME.UPDATE_TIME, ColumnType.INTEGER, -1, true), new ColumnInfo(COL_NAME.CREATE_TIME, ColumnType.INTEGER, -1, false) ]; const b1 = '[UserInfoTable]'; export class UserInfoTable extends RdbTableImpl { constructor(n1, o1) { super(n1); this.logger = o1.logger; registerAspect(USER_INFO_TABLE.tableName, UserInfoTable, o1); } async createTable() { try { this.createTableError = null; const k1 = { tableName: USER_INFO_TABLE.tableName, indexName: o, columns: [COL_NAME.ACCOUNT] }; const index = { indexName: t, columns: [COL_NAME.UPDATE_TIME] }; const l1 = { indexName: u, columns: [COL_NAME.NAME] }; const m1 = { indexName: a1, columns: [COL_NAME.MOBILE] }; await Promise.all([ await this.rdbStoreManager.createTable(USER_INFO_TABLE.tableName, false, UserInfoColumns), await this.rdbStoreManager.createTableUniqueIndex(k1), await this.rdbStoreManager.createIndex(USER_INFO_TABLE.tableName, index), await this.rdbStoreManager.createIndex(USER_INFO_TABLE.tableName, l1), await this.rdbStoreManager.createIndex(USER_INFO_TABLE.tableName, m1) ]); } catch (e) { this.createTableError = e; } } async upsertUsers(j1) { try { if (typeof j1 === 'undefined') { this.logger.info(b1, `upsertUsers user is undefined`); return; } await this.ensureCreateTable(); this.logger.info(b1, 'upsertUsers', j1); const valueBucket = []; if (Array.isArray(j1)) { if (j1.length <= 0) { this.logger.info(b1, `upsertUsers array illegal user: ${j1}`); return; } else { j1.map((item) => { valueBucket.push(item.generateBucket()); }); } } else { valueBucket.push(j1.generateBucket()); } await this.rdbStoreManager.insertOrReplace(USER_INFO_TABLE.tableName, valueBucket); } catch (e) { this.logger.error(b1, 'upsertUsers', j1, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `insertUserInfo ${JSON.stringify(j1)}`, rawError: e } }); } } async updateUser(userInfo) { try { await this.ensureCreateTable(); this.logger.info(b1, 'updateUser', userInfo); const valueBucket = userInfo.generateUpdateBucket(); const predicates = new RdbPredicates(USER_INFO_TABLE.tableName) .equalTo(COL_NAME.ACCOUNT, userInfo.accountId); return await this.rdbStoreManager.update(valueBucket, predicates); } catch (e) { this.logger.error(b1, 'updateUser', userInfo, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `updateUser ${userInfo}`, rawError: e } }); } } async queryUser(account) { try { await this.ensureCreateTable(); this.logger.info(b1, 'queryUser', account); const predicates = new RdbPredicates(USER_INFO_TABLE.tableName).equalTo(COL_NAME.ACCOUNT, account); const values = await this.rdbStoreManager.query(predicates); if (values.length > 0) { return V2NIMUserImpl.buildFromValueBucket(values[0]); } else { return undefined; } } catch (e) { this.logger.error(b1, 'queryUser', account, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `queryByAccount ${account}`, rawError: e } }); } } async queryAll(limit) { try { await this.ensureCreateTable(); this.logger.info(b1, 'queryAll'); const predicates = new RdbPredicates(USER_INFO_TABLE.tableName) .orderByDesc(COL_NAME.UPDATE_TIME) .limitAs(limit); const values = await this.rdbStoreManager.query(predicates); const result = []; values.map(value => { result.push(V2NIMUserImpl.buildFromValueBucket(value)); }); return result; } catch (e) { this.logger.error(b1, 'queryAll', e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `queryAll`, rawError: e } }); } } async queryUserList(i1) { try { if (!i1 || i1.length <= 0) { return []; } await this.ensureCreateTable(); this.logger.info(b1, 'queryUserList', i1); const predicates = new RdbPredicates(USER_INFO_TABLE.tableName) .in(COL_NAME.ACCOUNT, i1) .orderByDesc(COL_NAME.UPDATE_TIME); const values = await this.rdbStoreManager.query(predicates); const result = []; values.map(value => { result.push(V2NIMUserImpl.buildFromValueBucket(value)); }); return result; } catch (e) { this.logger.error(b1, 'queryUserList', i1, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `queryUserList ${i1}`, rawError: e } }); } } async searchUserByOption(c1, d1, e1, f1) { try { await this.ensureCreateTable(); this.logger.info(b1, 'searchUserByOption', c1, d1, e1, f1); const g1 = []; if (!d1 && !e1 && !f1) { return g1; } const predicates = new RdbPredicates(USER_INFO_TABLE.tableName); const h1 = `%${c1}%`; if (d1) { predicates.like(COL_NAME.NAME, h1); } if (e1) { if (d1) { predicates.or().like(COL_NAME.ACCOUNT, h1); } else { predicates.like(COL_NAME.ACCOUNT, h1); } } if (f1) { if (d1 || e1) { predicates.or().like(COL_NAME.MOBILE, h1); } else { predicates.like(COL_NAME.MOBILE, h1); } } const values = await this.rdbStoreManager.query(predicates); values.map(value => { g1.push(V2NIMUserImpl.buildFromValueBucket(value)); }); return g1; } catch (e) { this.logger.error(b1, 'searchUserByOption', c1, d1, e1, f1, e); throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `searchUserByOption`, rawError: e } }); } } } 