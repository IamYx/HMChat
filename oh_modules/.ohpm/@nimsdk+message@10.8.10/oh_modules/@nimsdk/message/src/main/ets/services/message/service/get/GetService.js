import HashMap from "@ohos.util.HashMap"; import { cmdConfigMessageGet, cmdMapMessageGet, registerParser, V2NIMErrorCode, V2NIMErrorImpl, V2NIMQueryDirection, validate, validateConversationId } from '@nimsdk/base'; import { get, set } from '@nimsdk/vendor/'; import { GetMessageListByRefersRequest } from '../../cloud/MessageRequest'; import { V2NIMMessageListOptionModel } from '../../model/V2NIMMessageListOptionModel'; import { V2NIMMessageModel } from '../../model/V2NIMMessageModel'; import { completeMessage } from '../../utils/Format'; import { getMessageListByRefersRule, getThreadMessageListRule, msgReferRule, searchCloudMessagesRule } from '../Rules'; import { GetCloud } from './GetCloud'; import { GetModel } from './GetModel'; const s41 = '[GetService]'; export class GetService { constructor(s58, table) { this.core = s58; registerParser(s58, { cmdMap: cmdMapMessageGet, cmdConfig: cmdConfigMessageGet }); this.model = new GetModel(table); this.cloud = new GetCloud(s58); } async getMessageList(option) { try { this.core.logger.info(s41, 'getMessageList', option); V2NIMMessageListOptionModel.validateParam(this.core.account, option); let q58 = new V2NIMMessageListOptionModel(option); if (q58.onlyQueryLocal) { return await this.getMessageListFormLocal(q58); } else if (!q58.strictMode && q58.isGetRecentMessages()) { let r58 = await this.getMessageListFormLocal(q58) ?? []; if (r58.length <= 0) { return await this.getMessageListDynamically(q58); } else { this.getMessageListDynamically(q58); return r58; } } else { return this.getMessageListDynamically(q58); } } catch (e) { this.core.logger.error(s41, 'getMessageList', option, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getMessageList ${JSON.stringify(e)}`, rawError: e } }); } } } async getMessageListDynamically(option) { let n58 = !option.onlyQueryLocal; let o58 = []; if (n58) { try { o58 = await this.getMessageListFromServer(option); } catch (e) { if (option.strictMode) { if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getMessageList ${JSON.stringify(e)}`, rawError: e } }); } } } } let p58 = await this.getMessageListDynamicHandler(o58, option); return p58; } async getUnreadMessageList(h58, i58) { try { this.core.logger.info(s41, 'getUnreadMessageList', h58, i58); validateConversationId(this.core.account, h58); const j58 = await this.model.queryConversationUnreadMessages(h58, i58); const k58 = j58.map((l58) => { const m58 = completeMessage(this.core, l58.transform()); return this.core.messageService.v2IProcessMessageAttachment(m58); }).filter((message) => { return message.messageConfig?.unreadEnabled; }); return k58; } catch (e) { this.core.logger.error(s41, 'getUnreadMessageList', h58, i58, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getUnreadMessageList ${JSON.stringify(e)}`, rawError: e } }); } } } async getUnreadMessageCount(f58, g58) { try { this.core.logger.info(s41, 'getUnreadMessageCount', f58, g58); validateConversationId(this.core.account, f58); return await this.model.queryConversationUnreadMessageCount(f58, g58); } catch (e) { this.core.logger.error(s41, 'getUnreadMessageCount', f58, g58, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getUnreadMessageCount ${JSON.stringify(e)}`, rawError: e } }); } } } async getMessageListByRefers(t57) { try { this.core.logger.info(s41, 'getMessageListByRefers', t57); validate(getMessageListByRefersRule, { messageRefers: t57 }, '', true); if (t57.length === 0) { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: 'getMessageListByRefers: messageRefers cannot be an empty array' } }); } const u57 = []; const v57 = []; for (const e58 of t57) { const model = await this.model.queryMessage(e58.messageClientId); if (model !== undefined) { v57.push(model); } if (model === undefined && e58.messageServerId && e58.messageServerId !== '0') { u57.push(e58); } } let w57 = []; if (u57.length > 0) { const d58 = (await this.core.sendCmd('v2GetMessageListByRefers', new GetMessageListByRefersRequest(u57))); w57 = get(d58.content, 'msgs'); } const x57 = []; for (const b58 of w57) { let c58 = completeMessage(this.core, b58); c58 = this.core.messageService.v2IProcessMessageAttachment(c58); if (await this.core.messageService.messageFilterShouldIgnore(c58)) { this.core.logger.info(s41, `msg: ${b58.messageClientId} is ignored in ignoredgetMessageListByRefers`); continue; } else { x57.push(c58); } } const y57 = x57.map((message) => { const msg = new V2NIMMessageModel().implement(message); return msg; }); const z57 = await this.model.saveMessages(y57); await this.core.localConversationService.onMessagesFetched(z57); const a58 = v57.concat(y57); return a58.map((msg) => { if (msg.isDeleted !== true) { const message = msg.transform(); return this.core.messageService.v2IProcessMessageAttachment(message); } return undefined; }).filter((msg) => typeof msg !== 'undefined'); } catch (e) { this.core.logger.error(s41, 'getMessageListByRefers', t57, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getMessageListByRefers ${JSON.stringify(e)}`, rawError: e } }); } } } async getMessageListByIds(r57) { try { this.core.logger.info(s41, 'getMessageListByIds', r57); if (r57.length <= 0) { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: 'getMessageListByIds: messageClientIds cannot be an empty array' } }); } const s57 = await this.model.queryMessages(r57); return s57.map(message => { const msg = message.transform(); return this.core.messageService.v2IProcessMessageAttachment(msg); }); } catch (e) { this.core.logger.error(s41, 'getMessageListByIds', r57, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getMessageListByIds ${JSON.stringify(e)}`, rawError: e } }); } } } async searchCloudMessages(params) { try { this.core.logger.info(s41, 'searchCloudMessages', params); validate(searchCloudMessagesRule, params, '', true); const q57 = await this.cloud.searchCloudMessages(params); return q57; } catch (e) { this.core.logger.error(s41, 'searchCloudMessages', params, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `searchCloudMessages ${JSON.stringify(e)}`, rawError: e } }); } } } async getThreadMessageList(option) { try { this.core.logger.info(s41, 'getThreadMessageList', option); validate(getThreadMessageListRule, option, 'getThreadMessageList', true); option.beginTime = option.beginTime || 0; if (option.endTime && option.beginTime > option.endTime) { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: 'getThreadMessageList: beginTime cannot be greater than endTime' } }); } const result = await this.cloud.getThreadMessageList(option); const l57 = []; if (this.core.messageService.messageFilter) { if (await this.core.messageService.messageFilterShouldIgnore(result.message)) { this.core.logger.info(s41, `root msg: ${result.message.messageClientId} is ignored at getThreadMessageList.`); result.message = option.messageRefer; } else { l57.push(new V2NIMMessageModel().implement(result.message)); } const o57 = []; for (const p57 of result.replyList) { if (await this.core.messageService.messageFilterShouldIgnore(p57)) { this.core.logger.info(s41, `reply msg: ${p57.messageClientId} is ignored at getThreadMessageList.`); } else { o57.push(p57); l57.push(new V2NIMMessageModel().implement(p57)); } } result.replyList = o57; } else { l57.push(new V2NIMMessageModel().implement(result.message)); for (const n57 of result.replyList) { l57.push(new V2NIMMessageModel().implement(n57)); } } if (l57.length > 0) { const m57 = await this.model.saveMessages(l57); await this.core.localConversationService.onMessagesFetched(m57); } return result; } catch (e) { this.core.logger.error(s41, 'getThreadMessageList', option, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getThreadMessageList ${JSON.stringify(e)}`, rawError: e } }); } } } async getLocalThreadMessageList(message) { try { this.core.logger.info(s41, 'getLocalThreadMessageList', message); validate(msgReferRule, message, 'message', true); const result = {}; const j57 = await this.model.queryMessage(message.messageClientId); if (j57 !== undefined && j57.isDeleted === false) { result.message = j57.transform(); } else { result.message = message; } const k57 = await this.model.queryThreadMessages(message.messageClientId); if (k57.length > 0) { result.timestamp = k57[k57.length - 1].createTime; } else { result.timestamp = 0; } result.replyList = k57.map(model => model.transform()); result.replyCount = k57.length; return result; } catch (e) { this.core.logger.error(s41, 'getLocalThreadMessageList', message, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getThreadMessageList ${JSON.stringify(e)}`, rawError: e } }); } } } async getMessageListDynamicHandler(o56, option) { this.core.logger.info(s41 + `getMessageListDynamicHandler, len:${o56.length}, option: ${JSON.stringify(option ?? {})}, ids: ${o56.map(msg => msg?.messageClientId)}`); const p56 = option.conversationId; let q56 = option.beginTime ?? 0; let endTime = option.endTime ?? 0; const r56 = option.anchorMessage; const direction = option.direction ?? 0; const limit = option.limit ?? 50; const s56 = option.messageTypes ?? []; const t56 = new Map(); let u56 = await this.model.queryMessagesByOperation(p56, q56, endTime, limit, s56, direction); const v56 = u56.filter(item => item.isDeleted) .map(item => item.messageClientId); const w56 = new HashMap(); const x56 = u56.filter(item => !item.isDeleted).map(item => { const i57 = item.transform(); w56.set(item.messageClientId, i57); return i57; }); const y56 = u56.filter(item => !item.isDeleted) .map(item => item.messageClientId); let z56 = o56.filter(item => v56.includes(item.messageClientId) === false); const a57 = []; for (const msg of o56) { if (v56.includes(msg.messageClientId) === false) { t56.set(msg.messageClientId, true); } if (y56.includes(msg.messageClientId) === true) { const h57 = w56.get(msg.messageClientId); msg.localExtension = h57.localExtension; msg.messageStatus.readReceiptSent = h57.messageStatus.readReceiptSent; const localPath = get(h57, 'attachment.path'); if (msg.attachment && typeof localPath === 'string' && localPath) { set(msg.attachment, 'path', localPath); } if (h57.aiConfig !== undefined && msg.aiConfig === undefined) { msg.aiConfig = h57.aiConfig; } } else { const model = new V2NIMMessageModel().implement(msg); a57.push(model); } } this.core.logger.info(s41, `fromServer before save saveModels`, a57.length); const b57 = await this.model.saveMessages(a57); let offset = 0; if (r56) { if (direction === V2NIMQueryDirection.V2NIM_QUERY_DIRECTION_DESC) { endTime = r56.createTime; } else { q56 = r56.createTime; } offset = x56.findIndex((msg) => msg.messageClientId === option.anchorMessage?.messageClientId); offset += 1; } for (let c57 = offset; c57 < x56.length; c57++) { const msg = x56[c57]; const d57 = !t56.get(msg.messageClientId); const e57 = msg.conversationId === p56; const f57 = msg.createTime > q56 && (msg.createTime < endTime || endTime === 0); const g57 = s56.length > 0 ? s56.includes(msg.messageType) : true; if (d57 && e57 && f57 && g57) { z56.push(msg); } } z56 = z56.sort((a, b) => direction === V2NIMQueryDirection.V2NIM_QUERY_DIRECTION_ASC ? a.createTime - b.createTime : b.createTime - a.createTime); z56 = z56.slice(0, limit); if (b57.length > 0) { this.core.logger.info(s41, `fromServer save newInsertedMessages`, b57.length); await this.core.localConversationService.onMessagesFetched(b57); } this.core.logger.info(s41, 'getMessageListDynamicHandler, len & ids:', z56.length, o56.map(msg => msg?.messageClientId)); return z56; } async getMessageListFormLocal(option) { this.core.logger.info(s41, 'getMessageListFormLocal', option); const b56 = option.conversationId; const c56 = option.anchorMessage; const limit = option.limit; const d56 = option.messageTypes; let e56 = option.beginTime; let endTime = option.endTime; const direction = option.direction ?? V2NIMQueryDirection.V2NIM_QUERY_DIRECTION_DESC; let f56 = await this.model.queryMessagesByOperationExclude(b56, e56, endTime, limit, d56, direction); let g56 = f56.map((msg) => { const m56 = msg.transform(); const n56 = completeMessage(this.core, m56); n56.sendingState = msg.sendingState; return this.core.messageService.v2IProcessMessageAttachment(n56); }); let offset = 0; if (c56) { if (direction === V2NIMQueryDirection.V2NIM_QUERY_DIRECTION_DESC) { endTime = c56.createTime; } else { e56 = c56.createTime; } offset = g56.findIndex((msg) => msg.messageClientId === c56.messageClientId); offset += 1; } let h56 = []; for (let i56 = offset; i56 < g56.length; i56++) { const msg = g56[i56]; const j56 = msg.conversationId === b56; const k56 = msg.createTime >= e56 && (msg.createTime < endTime || endTime === 0); const l56 = d56.length > 0 ? d56.includes(msg.messageType) : true; if (j56 && k56 && l56) { h56.push(msg); } } h56 = h56.sort((a, b) => direction === V2NIMQueryDirection.V2NIM_QUERY_DIRECTION_ASC ? a.createTime - b.createTime : b.createTime - a.createTime); h56 = h56.slice(0, limit); this.core.logger.info(s41, 'getMessageListFormLocal', h56.length); return h56; } async getMessageListFromServer(option) { let w55 = await this.cloud.getMessageList(option); let x55 = w55.map((message) => { const z55 = completeMessage(this.core, message); const a56 = this.core.messageService.v2IProcessMessageAttachment(z55); return a56; }); const y55 = []; for (const msg of x55) { if (await this.core.messageService.messageFilterShouldIgnore(msg)) { this.core.logger.info(s41, `msg: ${msg.messageClientId} is ignored in getMessageList`); continue; } else { y55.push(msg); } } this.core.logger.info(s41, `fromServer won't save modle when getMessageListFromServer`); return y55; } } 