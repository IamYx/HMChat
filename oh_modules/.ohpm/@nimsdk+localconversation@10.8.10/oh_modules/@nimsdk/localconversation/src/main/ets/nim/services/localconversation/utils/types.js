import { V2NIMConversationType, V2NIMErrorCode, V2NIMErrorImpl } from '@nimsdk/base'; export var SceneType; (function (d25) { d25[d25["P2P"] = 0] = "P2P"; d25[d25["TEAM"] = 1] = "TEAM"; d25[d25["SUPER_TEAM"] = 5] = "SUPER_TEAM"; })(SceneType || (SceneType = {})); export class MarkConvAckTuple { constructor(c25, type, timestamp) { this._conversationId = c25; this._type = type; this._timestamp = timestamp; } get conversationId() { return this._conversationId; } get type() { return this._type; } get timestamp() { return this._timestamp; } } export var V2NIMLocalConversationStatus; (function (b25) { b25[b25["NORMAL"] = 0] = "NORMAL"; b25[b25["DELETED"] = 1] = "DELETED"; })(V2NIMLocalConversationStatus || (V2NIMLocalConversationStatus = {})); export var NotifyEventType; (function (a25) { a25[a25["NO_EVENT"] = 0] = "NO_EVENT"; a25[a25["UPDATE_EVENT"] = 1] = "UPDATE_EVENT"; a25[a25["CREATE_EVENT"] = 2] = "CREATE_EVENT"; })(NotifyEventType || (NotifyEventType = {})); export class AddUnreadCountEvent { constructor(y24, z24) { this.notifyType = y24; this.isRecount = z24; } } export var AllowMode; (function (x24) { x24[x24["NO"] = 0] = "NO"; x24[x24["YES"] = 1] = "YES"; x24[x24["ONLY_TIME"] = 2] = "ONLY_TIME"; })(AllowMode || (AllowMode = {})); export var UpdateReadTimeMode; (function (w24) { w24[w24["NOTHING"] = 1] = "NOTHING"; w24[w24["UPDATE_TO_LATEST_MESSAGE"] = 2] = "UPDATE_TO_LATEST_MESSAGE"; })(UpdateReadTimeMode || (UpdateReadTimeMode = {})); export class ClearUnreadByIdsResult { constructor(u24, v24) { this.failedResults = u24; this.succeedEntities = v24; } get operationResults() { return this.failedResults; } get unreadCacheEntities() { return this.succeedEntities; } } export class NotifyEventPair { constructor(t24, eventType) { this.conversationId = t24; this.eventType = eventType; } } export class ConvTimePair { constructor(r24, s24) { this.updateTime = this.calculateUpdateTime(r24, s24.updateTime); this.sortOrder = this.calculateSortOrder(this.updateTime, s24.stickTop); } calculateUpdateTime(p24, q24) { if (p24 > q24) { return p24; } else { return q24; } } calculateSortOrder(updateTime, o24) { if (typeof o24 === 'undefined') { return updateTime; } else { return updateTime + (o24 ? 1000000000000000 : 0); } } } export class StickTopInfo { constructor(m24, updateTime, n24) { this._conversationId = m24; this._updateTime = updateTime; this._stickTop = n24; this._ext = ''; } get updateTime() { return this._updateTime; } get stickTop() { return this._stickTop; } get conversationId() { return this._conversationId; } get ext() { return this._ext; } } var e24; (function (l24) { l24["P2P"] = "p2p"; l24["TEAM"] = "team"; l24["SUPER_TEAM"] = "super_team"; })(e24 || (e24 = {})); export function getCloudStickTopId(i24, j24) { const k24 = j24.conversationIdUtil.parseConversationType(i24); let id = j24.conversationIdUtil.parseConversationTargetId(i24); switch (k24) { case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P: id = e24.P2P + '|' + id; break; case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM: id = e24.TEAM + '|' + id; break; case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM: id = e24.SUPER_TEAM + '|' + id; break; default: { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: `getCloudStickTopId conversationId is illegal` } }); } } return id; } export function getConversationIdFomCloud(id, g24) { const h24 = id.split('|'); const target = h24[1].trim(); if (id.startsWith(e24.P2P)) { return g24.conversationIdUtil.p2pConversationId(target); } else if (id.startsWith(e24.TEAM)) { return g24.conversationIdUtil.teamConversationId(target); } else if (id.startsWith(e24.SUPER_TEAM)) { return g24.conversationIdUtil.superTeamConversationId(target); } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INTERNAL, detail: { reason: `getConversationIdFomCloud id is illegal` } }); } } export function generateFilterKey(filter) { let f24 = filter.conversationTypes; if (f24) { f24 = f24.sort(); } return JSON.stringify({ conversationTypes: f24, ignoreMuted: filter.ignoreMuted }); } export class V2NIMLocalConversationUnreadCountChangedFilterImpl { constructor() { this.conversationTypes = undefined; this.ignoreMuted = false; this.equals = (filter) => { return JSON.stringify(this) === generateFilterKey(filter); }; } } 