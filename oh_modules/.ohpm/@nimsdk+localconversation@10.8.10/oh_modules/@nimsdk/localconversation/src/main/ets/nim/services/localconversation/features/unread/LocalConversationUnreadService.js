import { V2NIMErrorCode, V2NIMErrorImpl } from '@nimsdk/base'; import { ClearUnreadByIdsResult, generateFilterKey, NotifyEventType } from '../../utils/types'; import { UnreadCacheEntity } from './model/entity/UnreadCacheEntity'; import { LocalConversationUnreadModel } from './model/LocalConversationUnreadModel'; import HashMap from "@ohos.util.HashMap"; import HashSet from "@ohos.util.HashSet"; const e1 = '[LocalConversationUnreadService]'; export class LocalConversationUnreadService { constructor(g18, service) { this.core = g18; this.service = service; this.unreadChangedHandler = new UnreadChangedHandler(g18, service); this.model = new LocalConversationUnreadModel(g18, service, this.unreadChangedHandler); } async onDatabaseOpen() { const e18 = new Date().getTime(); await this.model.initCacheFromDb(); const f18 = new Date().getTime(); this.core.logger.info(e1, `initCacheFromDb cost ${f18 - e18} ms`); } getTotal() { return this.model.getTotal(); } getByIds(d18) { return this.model.getByIds(d18); } async getByFilter(filter) { const y17 = new HashSet(); if (filter.conversationTypes) { filter.conversationTypes.map(type => { y17.add(type); }); } const z17 = []; for (const c18 of this.model.queryAllCache().values()) { if (c18.unreadCount <= 0) { continue; } if (y17.length > 0) { if (y17.has(this.core.conversationIdUtil.parseConversationType(c18.conversationId))) { z17.push(c18); } else { continue; } } else { z17.push(c18); } } let total = 0; if (filter.ignoreMuted) { for (const b18 of z17) { if (b18.mute !== true) { total += b18.unreadCount; } } } else { for (const a18 of z17) { total += a18.unreadCount; } } return total; } async getReadTimeById(v17) { const w17 = this.model.queryCache(v17); if (w17) { return w17.timestamp; } const x17 = await this.model.queryReadTimeEntity(v17); if (x17) { return x17.timestamp; } else { return 0; } } async deleteByConversationIds(u17) { return this.model.deleteReadTimeBatch(u17); } async clearTotal() { const t17 = Array.from(this.model.queryAllCache().keys()); return await this.clearByIds(t17); } async clearByIds(i17) { const j17 = i17.filter((id) => { const s17 = this.model.queryCache(id); if (s17 && s17.unreadCount <= 0) { return false; } else { return true; } }); const results = []; const k17 = await this.service.attribute.getByIds(j17); const l17 = new HashSet(); k17.map((r17) => { l17.add(r17.conversationId); }); const m17 = j17.filter(id => !l17.has(id)); await Promise.all(m17.map(async (q17) => { results.push({ conversationId: q17, error: new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: `unread clearByIds ${q17} not exist` } }) }); if (this.model.queryCache(q17)) { this.core.logger.error(e1, `unexpected conversation missingId: ${q17}, which existing in cache not db.`); return await this.deleteByConversationIds([q17]); } else { return; } })); const entities = []; for (const n17 of k17) { let timestamp = n17.lastMessage?.messageRefer.createTime; if (!timestamp) { const p17 = await this.core.messageService.v2IGetLastMessageFast(n17.conversationId, false); if (typeof p17 !== 'undefined') { this.core.logger.info(e1, `use message latestMessage, id: ${p17.messageClientId}, lastMessageUpdateEnabled: ${p17.messageConfig?.lastMessageUpdateEnabled}`); timestamp = p17.createTime; } else { this.core.logger.info(e1, `unexpected conversation: ${n17.conversationId}, which doesn't have msg's createTime while unreadCount > 0`); continue; } } const o17 = new UnreadCacheEntity(n17.conversationId, 0, timestamp, !!n17.mute); entities.push(o17); } await this.model.updateConversations(entities); return new ClearUnreadByIdsResult(results, entities); } async clearByTypes(types) { const f17 = new HashSet(); types.map(type => { f17.add(type); }); const g17 = []; for (const h17 of this.model.queryAllCache().values()) { if (f17.has(this.core.conversationIdUtil.parseConversationType(h17.conversationId))) { g17.push(h17.conversationId); } } return await this.clearByIds(g17); } async clearBySyncTuple(e17) { return await this.model.clearBySyncTuple(e17, this.service.config); } addFilter(filter) { this.unreadChangedHandler.addFilter(filter); } deleteFilter(filter) { this.unreadChangedHandler.deleteFilter(filter); } async onMessageReceived(message) { const d17 = await this.doMessageReceived(message); await this.checkUnreadCache(message.conversationId, d17); return d17; } async onMessageInserted(message) { const c17 = await this.doMessageInserted(message); await this.checkUnreadCache(message.conversationId, c17); return c17; } async onMessagesDeleted(a17) { const b17 = await this.doMessagesDeleted(a17); await this.checkUnreadCacheBatch(b17); return b17; } async onMessagesRevoked(y16) { const z16 = await this.doMessagesRevoked(y16); await this.checkUnreadCacheBatch(z16); return z16; } async onMessagesCleared(w16) { const x16 = await this.doMessagesCleared(w16); await this.checkUnreadCacheBatch(x16); return x16; } async onMessagesSynced(u16) { const v16 = await this.doMessagesSynced(u16); await this.checkUnreadCacheBatch(v16); return v16; } async onMessagesFetched(s16) { const t16 = await this.doMessagesFetched(s16); await this.checkUnreadCacheBatch(t16); return t16; } async onMessageSent(message) { const r16 = await this.doMessageSent(message); await this.checkUnreadCache(message.conversationId, r16); return r16; } async onConversationSetMute(p16, mute) { const q16 = await this.doConversationSetMute(p16, mute); await this.checkUnreadCache(p16, q16); return q16; } async onMessagesModify(n16) { const o16 = await this.doMessagesModify(n16); await this.checkUnreadCacheBatch(o16); return o16; } async doMessageReceived(message) { if (!this.checkUnreadEnable(message)) { return NotifyEventType.NO_EVENT; } return await this.model.addUnreadCount(message, this.service.config); } async doMessageInserted(message) { if (!this.checkUnreadEnable(message)) { return NotifyEventType.NO_EVENT; } return await this.model.addUnreadCount(message, this.service.config); } async doMessagesDeleted(l16) { const m16 = l16.map((notify) => { return { senderId: notify.messageRefer.senderId, receiverId: notify.messageRefer.receiverId, messageClientId: notify.messageRefer.messageClientId, messageServerId: notify.messageRefer.messageServerId, createTime: notify.messageRefer.createTime, conversationType: notify.messageRefer.conversationType, conversationId: notify.messageRefer.conversationId }; }); return await this.model.recountUnreadCountBatch(m16, this.service.config); } async doMessagesRevoked(j16) { const k16 = j16.map((notify) => { return { senderId: notify.messageRefer.senderId, receiverId: notify.messageRefer.receiverId, messageClientId: notify.messageRefer.messageClientId, messageServerId: notify.messageRefer.messageServerId, createTime: notify.messageRefer.createTime, conversationType: notify.messageRefer.conversationType, conversationId: notify.messageRefer.conversationId }; }); return await this.model.recountUnreadCountBatch(k16, this.service.config); } async doMessagesCleared(h16) { const i16 = h16.map((notify) => { return { conversationId: notify.conversationId }; }); return await this.model.recountUnreadCountBatch(i16, this.service.config); } async doMessagesSynced(f16) { const g16 = this.keepUnreadEnableMessages(f16); if (g16.length <= 0) { return new HashMap(); } return await this.model.addUnreadCountBatch(g16, this.service.config); } async doMessagesFetched(d16) { const e16 = this.keepUnreadEnableMessages(d16); if (e16.length <= 0) { return new HashMap(); } return await this.model.addUnreadCountBatch(e16, this.service.config); } async doMessageSent(message) { return NotifyEventType.NO_EVENT; } async doConversationSetMute(c16, mute) { return await this.model.conversationSetMute(c16, mute, this.service.config); } async doMessagesModify(a16) { const b16 = new HashMap(); for (const msg of a16) { b16.set(msg.conversationId, NotifyEventType.NO_EVENT); } return b16; } async getOrCreateById(z15) { return await this.model.getOrCreateById(z15, this.service.config, true); } notifyUnreadCountChangedAfterSyncCompleted() { this.unreadChangedHandler.unreadCountChangedHandler(UnreadNotifyBy.SYNC_END, true, true); } notifyUnreadCountChangedAfterOnMessagesFetched() { this.unreadChangedHandler.unreadCountChangedHandler(UnreadNotifyBy.NORMAL, true, false); } async checkUnreadCache(x15, eventType) { const y15 = new HashMap(); y15.set(x15, eventType); await this.checkUnreadCacheBatch(y15); return; } async checkUnreadCacheBatch(v15) { for (const w15 of v15.keys()) { if (v15.get(w15) === NotifyEventType.NO_EVENT && !this.model.queryCache(w15)) { await this.model.getOrCreateById(w15, this.service.config, false); } } } checkUnreadEnable(message) { if (message.messageConfig?.unreadEnabled === false) { return false; } else { return true; } } keepUnreadEnableMessages(t15) { const u15 = t15.filter((message) => { return this.checkUnreadEnable(message); }); return u15; } } export class UnreadChangedHandler { constructor(s15, service) { this.unreadCountByFilter = new HashMap(); this.lastAtSyncStart = undefined; this.core = s15; this.service = service; } unreadCountChangedHandler(by, m15, n15) { const force = this.isForce(by); if (!force && !this.core.syncService.isBasicSyncComplete) { this.core.logger.info(e1, `wont notify unread count change while syncing`); return; } if (force || m15) { const r15 = this.service.unread.getTotal(); if (this.ifNotifyWhenSync(by, r15)) { this.service.triggerOnTotalUnreadCountChanged(r15); } else { this.core.logger.info(e1, `wont notify when unread count of SYNC_START equals to SYNC_END: ${r15}`); } } if (force || m15 || n15) { for (const o15 of this.unreadCountByFilter.keys()) { const filter = JSON.parse(o15); const p15 = this.unreadCountByFilter.get(o15); this.service.unread.getByFilter(filter).then((q15) => { this.unreadCountByFilter.set(o15, q15); if (force || p15 !== q15) { this.service.triggerOnUnreadCountChangedByFilter(filter, q15); } }); } } return; } addFilter(filter) { const j15 = generateFilterKey(filter); if (typeof this.unreadCountByFilter.get(j15) === 'undefined') { const k15 = JSON.parse(j15); this.service.unread.getByFilter(k15) .then((l15) => { this.unreadCountByFilter.set(j15, l15); this.service.emit('onUnreadCountChangedByFilter', k15, l15); }) .catch((e) => { this.core.logger.error(e1, `addFilter catch error`, e); }); } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_ALREADY_EXIST }); } } deleteFilter(filter) { const i15 = generateFilterKey(filter); if (typeof this.unreadCountByFilter.get(i15) === 'undefined') { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST }); } this.unreadCountByFilter.remove(i15); } isForce(by) { switch (by) { case UnreadNotifyBy.SYNC_START: case UnreadNotifyBy.SYNC_END: return true; case UnreadNotifyBy.NORMAL: default: return false; } } ifNotifyWhenSync(by, g15) { switch (by) { case UnreadNotifyBy.NORMAL: return true; case UnreadNotifyBy.SYNC_START: this.lastAtSyncStart = g15; return true; case UnreadNotifyBy.SYNC_END: let h15 = true; if (g15 === this.lastAtSyncStart) { h15 = false; } this.lastAtSyncStart = undefined; return h15; } } } export var UnreadNotifyBy; (function (f15) { f15[f15["NORMAL"] = 0] = "NORMAL"; f15[f15["SYNC_START"] = 1] = "SYNC_START"; f15[f15["SYNC_END"] = 2] = "SYNC_END"; })(UnreadNotifyBy || (UnreadNotifyBy = {})); 