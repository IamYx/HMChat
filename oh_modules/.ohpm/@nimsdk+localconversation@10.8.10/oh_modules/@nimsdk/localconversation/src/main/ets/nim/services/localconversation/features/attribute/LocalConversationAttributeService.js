import { V2NIMConversationType, V2NIMErrorCode, V2NIMErrorImpl, V2NIMLastMessageState, V2NIMMessageSendingState, V2NIMMessageType, V2NIMTeamType } from '@nimsdk/base'; import { ConvTimePair, AllowMode, NotifyEventType } from '../../utils/types'; import { LocalConversationAttributeModel } from './model/LocalConversationAttributeModel'; import HashMap from "@ohos.util.HashMap"; import { StickTopTimeEntity } from './model/entity/UnreadCacheEntity'; import { ReplaceLastMessageMode, ReplaceLastMessageRule } from './utils/types'; import { get } from '@nimsdk/vendor'; import { V2NIMLocalConversationImpl } from '../../impl/V2NIMLocalConversationImpl'; const e1 = '[LocalConversationAttributeService]'; export class LocalConversationAttributeService { constructor(r12, service) { this.core = r12; this.service = service; this.model = new LocalConversationAttributeModel(r12); } async getListByOption(offset, limit, option) { let o12 = 0; let p12 = true; let q12 = await this.model.query(limit + 1, offset, option); if (q12.length > limit) { p12 = false; q12 = q12.slice(0, limit); o12 = q12[q12.length - 1].sortOrder; } q12 = await this.computedFieldForConversations(q12); const result = { offset: o12, finished: p12, conversationList: q12 }; return result; } async getById(m12) { let n12 = await this.model.queryById(m12); if (typeof n12 !== 'undefined') { n12 = await this.computedFieldForConversation(n12); } return n12; } async getByIds(k12) { let l12 = await this.model.queryByIds(k12); l12 = await this.computedFieldForConversations(l12); return l12; } async create(h12) { let i12 = await this.getById(h12); if (typeof i12 !== 'undefined') { this.core.logger.info(e1, `create, but oldConversation is already exist: ${i12.conversationId}`); return i12; } else { const j12 = await this.forceCreate(h12); j12.unreadCount = await this.service.unread.getOrCreateById(j12.conversationId); this.core.logger.info(e1, `create, and notify new conversation: ${j12.conversationId}`); this.service.triggerOnConversationCreated(j12); return j12; } } async deleteById(f12) { const g12 = await this.model.queryById(f12); if (typeof g12 === 'undefined') { this.core.logger.info(e1, `deleteById, but conversation: ${f12} is not exist.`); throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: `deleteById failed, conversation: ${f12} is not exist.` } }); } await this.model.delete(f12, true); await this.service.unread.deleteByConversationIds([f12]); this.service.triggerOnConversationDeleted([f12]); return; } async deleteByIds(x11) { const y11 = await this.model.queryByIds(x11); const z11 = y11.map((e12) => { return e12.conversationId; }); if (z11.length > 0) { await this.model.deleteBatch(z11); await this.service.unread.deleteByConversationIds(z11); this.service.triggerOnConversationDeleted(z11); } const a12 = x11.filter((id) => { return !z11.includes(id); }); const b12 = a12.map((c12) => { const d12 = { conversationId: c12, error: new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, desc: `deleteByIds failed, conversation: ${c12} is not exist.` }) }; return d12; }); return b12; } async stickTop(r11, s11, updateTime) { if (!await this.allowAndUpdateStickTop(r11, s11, updateTime)) { this.core.logger.info(e1, `stickTop is out of date, conversation: ${r11}, stickTop: ${s11}, updateTime: ${updateTime}`); return; } const t11 = await this.model.queryById(r11); if (typeof t11 === 'undefined') { return; } if ((!!s11) === (!!t11.stickTop)) { this.core.logger.info(e1, `stickTop, equal to old stickTop, conversationId: ${r11}, stickTop: ${s11}`); return; } else { t11.stickTop = s11; } const u11 = new ConvTimePair(updateTime, t11); const v11 = { conversationId: r11, stickTop: !!s11, updateTime: u11.updateTime, sortOrder: u11.sortOrder }; await this.model.update(v11); const w11 = await this.getById(r11); if (w11) { this.service.triggerOnConversationChanged([w11]); } } async update(l11, m11) { const n11 = await this.model.queryById(l11); if (typeof n11 === 'undefined') { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: `update failed, conversation: ${l11} is not exist.` } }); } const o11 = new ConvTimePair(new Date().getTime(), n11); const p11 = { conversationId: l11, updateTime: o11.updateTime, sortOrder: o11.sortOrder }; await this.model.update(p11); const q11 = await this.getById(l11); if (q11) { this.service.triggerOnConversationChanged([q11]); } } async updateLocalExtension(f11, g11) { const h11 = await this.model.queryById(f11); if (typeof h11 === 'undefined') { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: `updateLocalExtension failed, conversation: ${f11} is not exist.` } }); } if (!g11) { g11 = ''; } if (g11 === h11.localExtension) { this.core.logger.info(e1, `updateLocalExtension, localExtension is equal to old localExtension`); return; } const i11 = new ConvTimePair(new Date().getTime(), h11); const j11 = { conversationId: f11, localExtension: g11, updateTime: i11.updateTime, sortOrder: i11.sortOrder }; await this.model.update(j11); const k11 = await this.getById(f11); if (k11) { this.service.triggerOnConversationChanged([k11]); } } async onMessageReceived(message) { return await this.replaceLastMessage(message, ReplaceLastMessageMode.REPLACE); } async onMessageSent(message) { return await this.replaceLastMessage(message, ReplaceLastMessageMode.REPLACE); } async onMessageInserted(message) { return await this.replaceLastMessage(message, ReplaceLastMessageMode.REPLACE); } async onMessagesModify(e11) { return await this.replaceLastMessages(e11, ReplaceLastMessageRule.MODIFY, ReplaceLastMessageMode.REPLACE); } async onMessagesSynced(d11) { return await this.replaceLastMessages(d11, ReplaceLastMessageRule.SYNC, ReplaceLastMessageMode.REPLACE); } async onMessagesFetched(c11) { return await this.replaceLastMessages(c11, ReplaceLastMessageRule.FETCH, ReplaceLastMessageMode.REPLACE); } async onMessagesDeleted(p10) { const q10 = new HashMap(); const r10 = this.uniqueConversationByDeletedNotifications(p10); const s10 = r10.keys(); for (const t10 of s10) { const notification = r10.get(t10); const u10 = await this.model.queryById(t10); if (typeof u10 === 'undefined') { await this.forceCreate(t10); q10.set(t10, NotifyEventType.CREATE_EVENT); continue; } const v10 = this.allowRecountOnDelete(notification.messageRefer, u10); switch (v10) { case AllowMode.YES: const w10 = await this.researchLastMessage(t10); const x10 = new ConvTimePair(notification.deleteTime, u10); const y10 = { conversationId: t10, lastMessage: w10, updateTime: x10.updateTime, sortOrder: x10.sortOrder }; await this.model.update(y10); q10.set(t10, NotifyEventType.UPDATE_EVENT); continue; case AllowMode.ONLY_TIME: const z10 = notification.deleteTime; const a11 = new ConvTimePair(z10, u10); const b11 = { conversationId: t10, updateTime: a11.updateTime, sortOrder: a11.sortOrder }; await this.model.update(b11); q10.set(t10, NotifyEventType.UPDATE_EVENT); continue; case AllowMode.NO: default: q10.set(t10, NotifyEventType.NO_EVENT); continue; } } return q10; } async onMessagesRevoked(a10) { const b10 = new HashMap(); const c10 = this.uniqueConversationByRevokeNotifications(a10); const d10 = c10.keys(); for (const e10 of d10) { const notification = c10.get(e10); const f10 = await this.model.queryById(e10); const g10 = 3; if (typeof f10 === 'undefined') { const o10 = await this.forceCreate(e10); if (g10 === 3) { o10.lastMessage = await this.mockLastMessageByRevokeNotification(notification); await this.model.update(o10); } b10.set(e10, NotifyEventType.CREATE_EVENT); continue; } const h10 = this.allowRecountOnRevoke(notification.messageRefer, f10); switch (h10) { case AllowMode.YES: let i10 = undefined; if (g10 === 1) { i10 = await this.researchLastMessage(e10); } else if (g10 === 2) { if (!f10.lastMessage) { b10.set(e10, NotifyEventType.NO_EVENT); continue; } else if (f10.lastMessage.messageRefer.messageClientId !== notification.messageRefer.messageClientId) { b10.set(e10, NotifyEventType.NO_EVENT); continue; } else if (f10.lastMessage.lastMessageState === V2NIMLastMessageState.V2NIM_MESSAGE_STATUS_REVOKE) { b10.set(e10, NotifyEventType.NO_EVENT); continue; } i10 = f10.lastMessage; i10.lastMessageState = V2NIMLastMessageState.V2NIM_MESSAGE_STATUS_REVOKE; i10.revokeType = notification.revokeType; i10.revokeAccountId = notification.revokeAccountId; i10.serverExtension = notification.serverExtension; i10.callbackExtension = notification.callbackExtension; if (notification.postscript) { i10.text = notification.postscript; } } else if (g10 === 3) { i10 = await this.mockLastMessageByRevokeNotification(notification); } const j10 = new ConvTimePair(new Date().getTime(), f10); const k10 = { conversationId: e10, lastMessage: i10, updateTime: j10.updateTime, sortOrder: j10.sortOrder }; await this.model.update(k10); b10.set(e10, NotifyEventType.UPDATE_EVENT); continue; case AllowMode.ONLY_TIME: const l10 = new Date().getTime(); const m10 = new ConvTimePair(l10, f10); const n10 = { conversationId: e10, updateTime: m10.updateTime, sortOrder: m10.sortOrder }; await this.model.update(n10); b10.set(e10, NotifyEventType.UPDATE_EVENT); continue; case AllowMode.NO: default: b10.set(e10, NotifyEventType.NO_EVENT); continue; } } return b10; } async onMessagesCleared(q9) { const r9 = new HashMap(); const s9 = this.uniqueConversationByClearNotifications(q9); const t9 = s9.keys(); for (const u9 of t9) { const v9 = s9.get(u9).deleteTime; const w9 = await this.model.queryById(u9); if (typeof w9 === 'undefined') { r9.set(u9, NotifyEventType.NO_EVENT); continue; } if (v9 <= w9.updateTime) { r9.set(u9, NotifyEventType.NO_EVENT); continue; } const x9 = await this.researchLastMessage(u9); const y9 = new ConvTimePair(v9, w9); const z9 = { conversationId: u9, lastMessage: x9, updateTime: y9.updateTime, sortOrder: y9.sortOrder }; await this.model.update(z9); r9.set(u9, NotifyEventType.UPDATE_EVENT); continue; } return r9; } async onConversationSetMute(m9, mute) { const n9 = await this.getById(m9); if (n9 && n9.mute !== mute) { const o9 = new ConvTimePair(n9.updateTime, n9); const p9 = { conversationId: m9, mute: mute, updateTime: o9.updateTime, sortOrder: o9.sortOrder }; await this.model.update(p9); return NotifyEventType.UPDATE_EVENT; } else { return NotifyEventType.NO_EVENT; } } async replaceLastMessage(message, b9) { const c9 = message.conversationId; const d9 = await this.model.queryById(c9); if (typeof d9 === 'undefined') { await this.forceCreate(c9); return NotifyEventType.CREATE_EVENT; } const e9 = this.allowUpdateLocalConvLastMessage(message, d9); switch (e9) { case AllowMode.YES: const f9 = await this.acquireLastMessageByReplaceMode(message, b9); let g9 = message.createTime; if (f9) { g9 = f9.messageRefer.createTime; } const h9 = new ConvTimePair(g9, d9); const i9 = { conversationId: c9, lastMessage: f9, updateTime: h9.updateTime, sortOrder: h9.sortOrder }; await this.model.update(i9); return NotifyEventType.UPDATE_EVENT; case AllowMode.ONLY_TIME: const j9 = message.createTime; const k9 = new ConvTimePair(j9, d9); const l9 = { conversationId: c9, updateTime: k9.updateTime, sortOrder: k9.sortOrder }; await this.model.update(l9); return NotifyEventType.UPDATE_EVENT; case AllowMode.NO: default: return NotifyEventType.NO_EVENT; } } async replaceLastMessages(l8, m8, n8) { const o8 = new HashMap(); const p8 = this.uniqueConversationByMessages(l8); const q8 = p8.keys(); for (const r8 of q8) { const message = p8.get(r8); const s8 = await this.model.queryById(r8); if (typeof s8 === 'undefined') { await this.forceCreate(r8); o8.set(r8, NotifyEventType.CREATE_EVENT); continue; } let t8 = AllowMode.NO; switch (m8) { case ReplaceLastMessageRule.FETCH: t8 = this.allowRecountOnFetch(message, s8); break; case ReplaceLastMessageRule.MODIFY: t8 = this.allowRecountOnModify(message, s8); break; case ReplaceLastMessageRule.SYNC: default: t8 = this.allowRecountOnSync(message, s8); break; } switch (t8) { case AllowMode.YES: const u8 = await this.acquireLastMessageByReplaceMode(message, n8); let v8 = message.createTime; if (u8) { v8 = u8.messageRefer.createTime; } const w8 = new ConvTimePair(v8, s8); const x8 = { conversationId: r8, lastMessage: u8, updateTime: w8.updateTime, sortOrder: w8.sortOrder }; await this.model.update(x8); o8.set(r8, NotifyEventType.UPDATE_EVENT); continue; case AllowMode.ONLY_TIME: const y8 = message.createTime; const z8 = new ConvTimePair(y8, s8); const a9 = { conversationId: r8, updateTime: z8.updateTime, sortOrder: z8.sortOrder }; await this.model.update(a9); o8.set(r8, NotifyEventType.UPDATE_EVENT); continue; case AllowMode.NO: default: o8.set(r8, NotifyEventType.NO_EVENT); continue; } } return o8; } async researchLastMessage(i8) { const j8 = await this.core.messageService.v2IGetLastMessageFast(i8, true); if (j8) { const k8 = await z3(this.core, j8, V2NIMLastMessageState.V2NIM_MESSAGE_STATUS_DEFAULT, j8.sendingState); return k8; } else { return undefined; } } uniqueConversationByMessages(f8) { const g8 = new HashMap(); for (const message of f8) { const h8 = message.conversationId; if (g8.hasKey(h8)) { if (message.createTime > g8.get(h8).createTime) { g8.set(h8, message); } else { continue; } } else { g8.set(h8, message); } } return g8; } uniqueConversationByDeletedNotifications(b8) { const c8 = new HashMap(); for (const notification of b8) { const d8 = notification.messageRefer; const e8 = d8.conversationId; if (c8.hasKey(e8)) { if (d8.createTime > c8.get(e8).messageRefer.createTime) { c8.set(e8, notification); } else { continue; } } else { c8.set(e8, notification); } } return c8; } uniqueConversationByRevokeNotifications(x7) { const y7 = new HashMap(); for (const notification of x7) { const z7 = notification.messageRefer; const a8 = z7.conversationId; if (y7.hasKey(a8)) { if (z7.createTime > y7.get(a8).messageRefer.createTime) { y7.set(a8, notification); } else { continue; } } else { y7.set(a8, notification); } } return y7; } uniqueConversationByClearNotifications(s7) { const t7 = new HashMap(); for (const u7 of s7) { const v7 = u7.conversationId; const w7 = u7.deleteTime; if (t7.hasKey(v7)) { if (w7 > t7.get(v7).deleteTime) { t7.set(v7, u7); } else { continue; } } else { t7.set(v7, u7); } } return t7; } async acquireLastMessageByReplaceMode(message, r7) { switch (r7) { case ReplaceLastMessageMode.REPLACE: return await z3(this.core, message, V2NIMLastMessageState.V2NIM_MESSAGE_STATUS_DEFAULT, message.sendingState); case ReplaceLastMessageMode.RESEARCH: default: return await this.researchLastMessage(message.conversationId); } } async computedFieldForConversationBatch(q6) { const r6 = []; const s6 = []; const t6 = []; for (const c of q6) { switch (c.type) { case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P: r6.push(c.conversationId); break; case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM: s6.push(c.conversationId); break; case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM: t6.push(c.conversationId); break; default: break; } } const u6 = r6.map((q7) => { return this.core.conversationIdUtil.parseConversationTargetId(q7); }); const v6 = s6.map((p7) => { return this.core.conversationIdUtil.parseConversationTargetId(p7); }); const w6 = t6.map((o7) => { return this.core.conversationIdUtil.parseConversationTargetId(o7); }); let x6 = new HashMap(); let y6 = new HashMap(); let z6 = new HashMap(); if (this.core.settingService?.name) { x6 = await this.core.settingService.v2IGetConversationMuteStatusBatch(u6, V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P); y6 = await this.core.settingService.v2IGetConversationMuteStatusBatch(v6, V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM); z6 = await this.core.settingService.v2IGetConversationMuteStatusBatch(w6, V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM); } let a7 = new HashMap(); let b7 = new HashMap(); if (this.core.userService?.name) { a7 = await this.core.friendService.v2IGetLocalFriendAliasBatch(u6); b7 = await this.core.userService.v2IGetLocalUsers(u6); } let c7 = new HashMap(); let d7 = new HashMap(); if (this.core.teamService?.name) { c7 = await this.core.teamService.v2IGetLocalTeamByIds(v6, V2NIMTeamType.V2NIM_TEAM_TYPE_NORMAL); d7 = await this.core.teamService.v2IGetLocalTeamByIds(w6, V2NIMTeamType.V2NIM_TEAM_TYPE_SUPER); } for (const e7 of q6) { if (e7.type === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_UNKNOWN) { continue; } const f7 = this.core.conversationIdUtil.parseConversationType(e7.conversationId); const g7 = this.core.conversationIdUtil.parseConversationTargetId(e7.conversationId); if (this.core.settingService?.name) { switch (f7) { case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P: e7.mute = x6.get(g7); break; case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM: e7.mute = y6.get(g7); break; case V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM: e7.mute = z6.get(g7); break; default: break; } } if (f7 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P && this.core.userService.name) { const l7 = a7.get(g7); const m7 = b7.get(g7); const n7 = this.getRemoteSenderName(e7); e7.name = l7 || (m7 && m7.name) || n7 || g7; e7.avatar = (m7 && m7.avatar) || ''; } else if (f7 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM && this.core.teamService.name) { const j7 = c7.get(g7); const k7 = this.getTeamNameByConversation(e7); e7.name = (j7 && j7.name) || k7 || g7; e7.avatar = (j7 && j7.avatar) || ''; } else if (f7 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM && this.core.teamService.name) { const h7 = d7.get(g7); const i7 = this.getTeamNameByConversation(e7); e7.name = (h7 && h7.name) || i7 || g7; e7.avatar = (h7 && h7.avatar) || ''; } } return q6; } async computedFieldForConversation(g6) { if (g6.type === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_UNKNOWN) { return g6; } const h6 = this.core.conversationIdUtil.parseConversationType(g6.conversationId); const i6 = this.core.conversationIdUtil.parseConversationTargetId(g6.conversationId); if (this.core.settingService?.name) { g6.mute = await this.core.settingService.v2IGetConversationMuteStatus(g6.conversationId); } if (h6 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P && this.core.userService.name) { const n6 = await this.core.friendService.v2IGetLocalFriendAlias(i6); const o6 = await this.core.userService.v2IGetLocalUser(i6); const p6 = this.getRemoteSenderName(g6); g6.name = n6 || (o6 && o6.name) || p6 || i6; g6.avatar = (o6 && o6.avatar) || ''; } else if (h6 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM && this.core.teamService.name) { const l6 = await this.core.teamService.v2IGetLocalTeamById(i6, V2NIMTeamType.V2NIM_TEAM_TYPE_NORMAL); const m6 = this.getTeamNameByConversation(g6); g6.name = (l6 && l6.name) || m6 || i6; g6.avatar = (l6 && l6.avatar) || ''; } else if (h6 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM && this.core.teamService.name) { const j6 = await this.core.teamService.v2IGetLocalTeamById(i6, V2NIMTeamType.V2NIM_TEAM_TYPE_SUPER); const k6 = this.getTeamNameByConversation(g6); g6.name = (j6 && j6.name) || k6 || i6; g6.avatar = (j6 && j6.avatar) || ''; } return g6; } getTeamNameByConversation(e6) { const f6 = get(e6.lastMessage ?? '', 'attachment.updatedTeamInfo.name'); if (typeof f6 !== 'string') { return undefined; } else { return f6; } } async computedFieldForConversations(c6) { const d6 = await this.computedFieldForConversationBatch(c6); this.core.logger.info(e1, `computedFieldForConversations done.`); return d6; } allowUpdateLocalConvLastMessage(x5, y5) { if (typeof x5 === 'undefined') { this.core.logger.error(e1, 'allowUpdateLocalConvLastMessage message is null'); return AllowMode.NO; } if (typeof x5.conversationId === 'undefined' || x5.conversationId.length <= 0) { this.core.logger.error(e1, `allowUpdateLocalConvLastMessage msg: ${x5.messageClientId} conversationId is empty`); return AllowMode.NO; } if (x5.conversationId !== y5.conversationId) { this.core.logger.error(e1, `allowUpdateLocalConvLastMessage unmatched msg: ${x5.messageClientId} to conversation`); return AllowMode.NO; } const z5 = x5.messageConfig?.lastMessageUpdateEnabled ?? true; if (!z5) { this.core.logger.info(e1, `allowUpdateLocalConvLastMessage msg: ${x5.messageClientId} conversationUpdateEnabled is false`); if (x5.createTime > y5.updateTime) { return AllowMode.ONLY_TIME; } else { return AllowMode.NO; } } const a6 = y5.lastMessage; if (typeof a6 === 'undefined') { return AllowMode.YES; } const b6 = a6.messageRefer; if (typeof b6 === 'undefined') { return AllowMode.YES; } if (a6.messageRefer.messageClientId === x5.messageClientId && a6.sendingState === V2NIMMessageSendingState.V2NIM_MESSAGE_SENDING_STATE_SENDING && (x5.sendingState === V2NIMMessageSendingState.V2NIM_MESSAGE_SENDING_STATE_SUCCEEDED || x5.sendingState === V2NIMMessageSendingState.V2NIM_MESSAGE_SENDING_STATE_FAILED)) { return AllowMode.YES; } if (x5.createTime < b6.createTime) { this.core.logger.info(e1, `allowUpdateLocalConvLastMessage end, last message time ${b6.createTime} > this message time ${x5.createTime}, conversationId: ${x5.conversationId}`); return AllowMode.NO; } else { return AllowMode.YES; } } allowRecountOnDelete(v5, w5) { return this.allowRecountLocalConvLastMessage(v5, w5, true, false); } allowRecountOnRevoke(t5, u5) { return this.allowRecountLocalConvLastMessage(t5, u5, true, false); } allowRecountOnModify(r5, s5) { return this.allowRecountLocalConvLastMessage(r5, s5, true, true); } allowRecountOnSync(p5, q5) { return this.allowRecountLocalConvLastMessage(p5, q5, false, true); } allowRecountOnFetch(n5, o5) { return this.allowRecountLocalConvLastMessage(n5, o5, false, true); } allowRecountLocalConvLastMessage(g5, h5, i5, j5) { if (typeof g5 === 'undefined') { this.core.logger.error(e1, 'allowRecountLocalConvLastMessage message is null'); return AllowMode.NO; } if (typeof g5.conversationId === 'undefined' || g5.conversationId.length <= 0) { this.core.logger.error(e1, `allowRecountLocalConvLastMessage msg: ${g5.messageClientId} conversationId is empty`); return AllowMode.NO; } if (g5.conversationId !== h5.conversationId) { this.core.logger.error(e1, 'allowRecountLocalConvLastMessage unmatched msg', g5, ' to  conversation:', h5); return AllowMode.NO; } const k5 = get(g5, 'messageConfig.lastMessageUpdateEnabled') ?? true; if (!k5) { this.core.logger.info(e1, `allowRecountLocalConvLastMessage msg: ${g5.messageClientId} conversationUpdateEnabled is false`); if (g5.createTime > h5.updateTime) { return AllowMode.ONLY_TIME; } else { return AllowMode.NO; } } const l5 = h5.lastMessage; if (typeof l5 === 'undefined') { return j5 ? AllowMode.YES : AllowMode.NO; } const m5 = l5.messageRefer; if (typeof m5 === 'undefined') { return j5 ? AllowMode.YES : AllowMode.NO; } if (g5.createTime < m5.createTime) { this.core.logger.info(e1, `allowUpdateLocalConvLastMessage end, last message time ${m5.createTime} > this message time ${g5.createTime}, conversationId: ${g5.conversationId}`); return AllowMode.NO; } if (g5.messageClientId === m5.messageClientId) { return i5 ? AllowMode.YES : AllowMode.NO; } else { return AllowMode.YES; } } async allowAndUpdateStickTop(e5, f5, updateTime) { if (f5) { return await this.allowAndAddStickTop(e5, updateTime); } else { return await this.allowAndDeleteStickTop(e5, updateTime); } } async allowAndAddStickTop(b5, updateTime) { const c5 = await this.model.queryStickTopTimeById(b5); if (c5 && updateTime <= c5.updateTime) { return false; } else { const d5 = new StickTopTimeEntity(b5, updateTime, c5 ? c5.ext : ''); await this.model.upsertStickTopTime(d5); return true; } } async allowAndDeleteStickTop(z4, updateTime) { const a5 = await this.model.queryStickTopTimeById(z4); if (a5 && updateTime > a5.updateTime) { await this.model.deleteStickTopTime([z4]); return true; } else { return false; } } async forceCreate(u4) { const v4 = await this.researchLastMessage(u4); const now = new Date().getTime(); let w4 = V2NIMLocalConversationImpl.buildFromParams(u4, this.core.conversationIdUtil.parseConversationType(u4), undefined, undefined, undefined, false, '', v4, 0, now, now, now); w4 = await this.computedFieldForConversation(w4); const x4 = await this.model.queryStickTopTimeById(u4); if (x4) { w4.stickTop = true; const y4 = new ConvTimePair(now, w4); w4.updateTime = y4.updateTime; w4.sortOrder = y4.sortOrder; } await this.model.insert(w4); return w4; } async mockLastMessageByRevokeNotification(notification) { const r4 = notification.messageRefer; const s4 = await a4(this.core, notification.revokeAccountId, r4.conversationType, r4.receiverId) || ''; const t4 = { messageType: V2NIMMessageType.V2NIM_MESSAGE_TYPE_TEXT, sendingState: V2NIMMessageSendingState.V2NIM_MESSAGE_SENDING_STATE_SUCCEEDED, messageRefer: r4, text: notification.postscript, lastMessageState: V2NIMLastMessageState.V2NIM_MESSAGE_STATUS_REVOKE, serverExtension: notification.serverExtension, revokeAccountId: notification.revokeAccountId, revokeType: notification.revokeType, callbackExtension: notification.callbackExtension, senderName: s4 }; return t4; } async queryAllStickTopTimeIds() { return await this.model.queryAllStickTopTimeIds(); } async deleteStickTopTimeNotIn(q4) { return await this.model.deleteStickTopTimeNotIn(q4); } getRemoteSenderName(o4) { const p4 = this.core.conversationIdUtil.parseConversationTargetId(o4.conversationId); if (o4.lastMessage && o4.lastMessage.messageRefer.senderId === p4) { return o4.lastMessage.senderName; } else { return undefined; } } } async function z3(k4, message, l4 = V2NIMLastMessageState.V2NIM_MESSAGE_STATUS_DEFAULT, m4) { message = k4.messageService.v2IProcessMessageAttachment(message); const n4 = await a4(k4, message.senderId, message.conversationType, message.receiverId, message) || ''; return JSON.parse(JSON.stringify({ lastMessageState: l4, messageRefer: k4.messageService.v2IFormatMessageRefer(message), messageType: message.messageType, subType: message.subType, text: message.text, attachment: message.attachment, serverExtension: message.serverExtension, localExtension: message.localExtension, sendingState: m4, callbackExtension: message.callbackExtension, senderName: n4 })); } async function a4(b4, c4, d4, e4, message) { if (c4 === b4.account) { return ''; } const f4 = await b4.friendService.v2IGetFriend(c4); if (f4 && f4.alias) { return f4.alias; } if (d4 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_TEAM) { const j4 = await b4.teamService.v2IGetLocalTeamMemberById(e4, V2NIMTeamType.V2NIM_TEAM_TYPE_NORMAL, c4); if (j4 && j4.teamNick) { return j4.teamNick; } } else if (d4 === V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM) { const i4 = await b4.teamService.v2IGetLocalTeamMemberById(e4, V2NIMTeamType.V2NIM_TEAM_TYPE_SUPER, c4); if (i4 && i4.teamNick) { return i4.teamNick; } } if (typeof message !== 'undefined') { const h4 = get(message, 'fromNick'); if (typeof h4 !== 'undefined') { return h4; } } const g4 = await b4.userService.v2IGetLocalUser(c4); if (g4 && g4.name) { return g4.name; } return c4; } 