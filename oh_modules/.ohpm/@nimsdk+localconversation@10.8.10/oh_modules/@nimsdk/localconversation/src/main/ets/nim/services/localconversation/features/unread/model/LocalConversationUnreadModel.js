import { NIM_DATABASE_NAME_MAIN, V2NIMErrorImpl, V2NIMErrorMap } from '@nimsdk/base'; import { LocalConversationUnreadTable } from '../../../db/LocalConversationUnreadTable'; import HashMap from "@ohos.util.HashMap"; import HashSet from "@ohos.util.HashSet"; import { UnreadCacheEntity, UnreadCacheSubReadTimeEntity, UnreadCacheSubUnreadCountEntity } from './entity/UnreadCacheEntity'; import { LocalConversationReadTimeTable } from '../../../db/LocalConversationReadTimeTable'; import { AddUnreadCountEvent, NotifyEventType, UpdateReadTimeMode } from '../../../utils/types'; import { UnreadCacheMap } from './entity/UnreadCacheMap'; const e1 = '[LocalConversationUnreadModel]'; export class LocalConversationUnreadModel { constructor(v22, service, w22) { this.core = v22; this.service = service; this.rdbStoreManager = v22.databaseService.getDatabase(v22, NIM_DATABASE_NAME_MAIN); this.unreadTable = new LocalConversationUnreadTable(this.rdbStoreManager, v22); this.readTimeTable = new LocalConversationReadTimeTable(this.rdbStoreManager, v22); this.cacheMap = new UnreadCacheMap(w22); } async initCacheFromDb() { let m22 = await this.readTimeTable.queryAll(); let n22 = await this.unreadTable.queryByIds(m22.map((u22) => u22.conversationId)); const o22 = new HashMap(); for (const t22 of m22) { o22.set(t22.conversationId, t22); } const p22 = new HashMap(); await Promise.all(n22.map(async (q22) => { const r22 = o22.get(q22.conversationId); const s22 = await this.core.settingService.v2IGetConversationMuteStatus(q22.conversationId); p22.set(q22.conversationId, new UnreadCacheEntity(q22.conversationId, q22.unreadCount, r22.timestamp, s22)); return; })); this.core.logger.info(e1, `initCacheFromDb, loadCacheMap size: ${p22.length}`); this.cacheMap.load(p22); } queryCache(l22) { if (this.cacheMap.hasKey(l22)) { return this.cacheMap.get(l22); } else { return null; } } queryAllCache() { return this.cacheMap; } updateCacheBatch(entities) { return this.cacheMap.setBatch(entities); } getTotal() { let total = 0; for (const k22 of this.cacheMap.values()) { total += k22.unreadCount; } return total; } async getOrCreateById(j22, config, notify) { if (!this.cacheMap.hasKey(j22)) { const result = await this.recountUnreadCount(j22, config, notify); if (result == NotifyEventType.CREATE_EVENT) { await this.syncReadTimeToDb(j22); } await this.syncUnreadCountToDb(j22); } if (this.cacheMap.hasKey(j22)) { return this.cacheMap.get(j22).unreadCount; } else { return 0; } } getByIds(g22) { let total = 0; const h22 = Array.from(new Set(g22)); for (const i22 of h22) { if (this.cacheMap.hasKey(i22)) { total += this.cacheMap.get(i22).unreadCount; } } return total; } async addUnreadCount(message, config) { const addEvent = await this.addUnreadCountInMemory(message, config, true); const result = addEvent.notifyType; if (result != NotifyEventType.NO_EVENT) { await this.syncUnreadCountToDb(message.conversationId); if (result == NotifyEventType.CREATE_EVENT) { await this.syncReadTimeToDb(message.conversationId); } } return result; } async addUnreadCountBatch(c22, config) { const results = new HashMap(); const d22 = new HashSet(); const e22 = new HashSet(); const f22 = new HashSet(); for (const message of c22) { if (f22.has(message.conversationId)) { continue; } const addEvent = await this.addUnreadCountInMemory(message, config, false); if (addEvent.isRecount) { f22.add(message.conversationId); } const result = addEvent.notifyType; this.core.logger.info(e1, `addUnreadCountBatch`, result, message); results.set(message.conversationId, result); if (result != NotifyEventType.NO_EVENT) { d22.add(message.conversationId); if (result == NotifyEventType.CREATE_EVENT) { e22.add(message.conversationId); } } } if (d22.length > 0) { this.service.unread.notifyUnreadCountChangedAfterOnMessagesFetched(); } await this.syncReadTimeAndUnreadCountToDb(e22, d22); return results; } async addUnreadCountInMemory(message, config, x21 = true) { const y21 = message.conversationId; if (!y21 || y21.length == 0) { return new AddUnreadCountEvent(NotifyEventType.NO_EVENT, false); } if (message.isSelf) { return new AddUnreadCountEvent(NotifyEventType.NO_EVENT, false); } if (this.cacheMap.hasKey(message.conversationId)) { const z21 = this.cacheMap.get(message.conversationId); if (message.createTime <= z21.timestamp) { return new AddUnreadCountEvent(NotifyEventType.NO_EVENT, false); } const a22 = new UnreadCacheEntity(message.conversationId, z21.unreadCount + 1, z21.timestamp, z21.mute); let b22 = false; if (x21) { b22 = this.cacheMap.set(message.conversationId, a22); } else { b22 = this.cacheMap.setWithoutNotify(message.conversationId, a22); } return new AddUnreadCountEvent(b22 ? NotifyEventType.UPDATE_EVENT : NotifyEventType.NO_EVENT, false); } else { return new AddUnreadCountEvent(await this.recountUnreadCount(message.conversationId, config, x21), true); } } async recountUnreadCountBatch(s21, config) { const t21 = new HashSet(); for (const message of s21) { t21.add(message.conversationId); } const results = new HashMap(); const u21 = new HashSet(); const v21 = new HashSet(); for (const w21 of t21) { const result = await this.recountUnreadCount(w21, config); results.set(w21, result); if (result != NotifyEventType.NO_EVENT) { u21.add(w21); if (result == NotifyEventType.CREATE_EVENT) { v21.add(w21); } } } await this.syncReadTimeAndUnreadCountToDb(v21, u21); return results; } async recountUnreadCount(j21, config, k21 = true, l21 = 0) { const m21 = await this.service.attribute.getById(j21); if (!m21) { return NotifyEventType.NO_EVENT; } let n21 = false; let o21 = 0; if (this.cacheMap.hasKey(j21)) { o21 = this.cacheMap.get(j21).timestamp; n21 = true; } else { const results = await this.readTimeTable.queryByIds([j21]); if (results.length > 0) { o21 = results[0].timestamp; } else { o21 = 0; } n21 = results.length > 0 && !!(await this.unreadTable.queryById(j21)); } const p21 = new UnreadCacheEntity(j21, m21.unreadCount, o21, m21.mute); const q21 = l21 >= o21 ? l21 : o21; const r21 = await this.recountUnreadCountByReadTime(j21, q21, config, k21, p21.mute); if (p21.equalsTo(r21)) { this.core.logger.info(e1, 'recountUnreadCount, entity did not change, entity', r21); return NotifyEventType.NO_EVENT; } else { this.core.logger.info(e1, 'recountUnreadCount, entity changed, old', p21, 'new: ', r21); return n21 ? NotifyEventType.UPDATE_EVENT : NotifyEventType.CREATE_EVENT; } } async conversationSetMute(g21, mute, config) { if (!this.cacheMap.hasKey(g21)) { return await this.recountUnreadCount(g21, config); } const h21 = this.cacheMap.get(g21); if (!!mute === !!h21.mute) { return NotifyEventType.NO_EVENT; } else { const i21 = new UnreadCacheEntity(h21.conversationId, h21.unreadCount, h21.timestamp, mute); this.cacheMap.set(g21, i21); return NotifyEventType.UPDATE_EVENT; } } async recountUnreadCountByReadTime(b21, c21, config, d21 = true, mute) { const e21 = await this.core.messageService.v2IGetUnreadMessageCount(b21, c21); const f21 = new UnreadCacheEntity(b21, e21, c21, mute); if (d21) { this.cacheMap.set(b21, f21); } else { this.cacheMap.setWithoutNotify(b21, f21); } return f21; } async syncReadTimeToDb(y20) { const z20 = this.cacheMap.get(y20); if (z20) { const a21 = new UnreadCacheSubReadTimeEntity(z20.conversationId, z20.timestamp); await this.readTimeTable.upsert(a21); return true; } else { return false; } } async upsertReadTimeToDb(v20, timestamp) { const w20 = await this.queryReadTimeEntity(v20); if (w20 && timestamp <= w20.timestamp) { return; } else { const x20 = new UnreadCacheSubReadTimeEntity(v20, timestamp); await this.readTimeTable.upsert(x20); } } async syncUnreadCountToDb(s20) { const t20 = this.cacheMap.get(s20); if (t20) { const u20 = new UnreadCacheSubUnreadCountEntity(t20.conversationId, t20.unreadCount); await this.unreadTable.updateUnreadCount(u20); return true; } else { return false; } } async syncReadTimeAndUnreadCountToDb(o20, p20) { try { await this.rdbStoreManager.beginTransaction(); for (const r20 of o20) { await this.syncReadTimeToDb(r20); } for (const q20 of p20) { await this.syncUnreadCountToDb(q20); } await this.rdbStoreManager.commit(); } catch (e) { await this.rdbStoreManager.rollBack(); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `localconversation clearTotal`, rawError: e } }); } } } async deleteReadTimeBatch(l20) { this.cacheMap.removeBatch(l20); const m20 = 1; if (m20 === UpdateReadTimeMode.NOTHING) { } else if (m20 === UpdateReadTimeMode.UPDATE_TO_LATEST_MESSAGE) { for (const id of l20) { const message = await this.core.messageService.v2IGetLastMessageFast(id, true); if (message) { const time = message.createTime; const n20 = new UnreadCacheSubReadTimeEntity(id, time); await this.readTimeTable.upsert(n20); } } } return; } async clearBySyncTuple(f20, config) { let g20 = 0; let h20 = false; if (this.cacheMap.hasKey(f20.conversationId)) { const k20 = this.cacheMap.get(f20.conversationId); g20 = k20.timestamp; h20 = true; } else { const j20 = await this.queryReadTimeEntity(f20.conversationId); if (j20) { g20 = j20.timestamp; } else { g20 = 0; } h20 = !!(await this.unreadTable.queryById(f20.conversationId)); } if (f20.timestamp <= g20) { return NotifyEventType.NO_EVENT; } if (h20) { const i20 = await this.recountUnreadCount(f20.conversationId, config, true, f20.timestamp); await this.syncReadTimeToDb(f20.conversationId); await this.syncUnreadCountToDb(f20.conversationId); return i20; } else { await this.upsertReadTimeToDb(f20.conversationId, f20.timestamp); return NotifyEventType.NO_EVENT; } } async updateConversations(entities) { try { await this.rdbStoreManager.beginTransaction(); this.updateCacheBatch(entities); for (const c20 of entities) { const d20 = new UnreadCacheSubReadTimeEntity(c20.conversationId, c20.timestamp); const e20 = new UnreadCacheSubUnreadCountEntity(c20.conversationId, c20.unreadCount); await this.readTimeTable.upsert(d20); await this.unreadTable.updateUnreadCount(e20); } await this.rdbStoreManager.commit(); return; } catch (e) { await this.rdbStoreManager.rollBack(); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `localconversation clearTotal`, rawError: e } }); } } } async queryReadTimeEntity(b20) { return await this.readTimeTable.queryById(b20); } } 