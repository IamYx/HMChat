import { cmdConfigLocalConversation, cmdMapLocalConversation, registerParser, V2NIMConversationType, V2NIMDataSyncState, V2NIMDataSyncType, V2NIMErrorCode, V2NIMErrorImpl, V2NIMLoginStatus, V2NIMMessageSendingState, V2Service, validate, validateConversationId } from '@nimsdk/base'; import { assign, get } from '@nimsdk/vendor'; import { LocalConversationAttributeService } from './features/attribute/LocalConversationAttributeService'; import { LocalConversationCloudService } from './features/cloud/LocalConversationCloudService'; import { LocalConversationUnreadService } from './features/unread/LocalConversationUnreadService'; import { registerAspect } from './utils/aspect'; import { getConversationIdFomCloud, MarkConvAckTuple, NotifyEventType, SceneType, StickTopInfo } from './utils/types'; import HashMap from "@ohos.util.HashMap"; import HashSet from "@ohos.util.HashSet"; import JSON from "@ohos.util.json"; const e1 = '[V2NIMLocalConversationService]'; export default class V2NIMLocalConversationServiceImpl extends V2Service { constructor(c31, serviceName, config) { super(serviceName, c31); this.isLogin = false; registerParser(c31, { cmdMap: cmdMapLocalConversation, cmdConfig: cmdConfigLocalConversation }); this.config = assign({}, config); this.setListener(); registerAspect(V2NIMLocalConversationServiceImpl, c31); } setListener() { this.core.eventBus.on('V2NIMLocalConversationService/onDataSync', (type, state, error) => { this.core.logger.info(e1, `on V2NIMLocalConversationService/onDataSync, type: ${type}, state: ${state}, error: ${error}, `); this.observeMainSyncState(type, state, error); }); } registerInnerService() { this._attribute = new LocalConversationAttributeService(this.core, this); this._unread = new LocalConversationUnreadService(this.core, this); this._cloud = new LocalConversationCloudService(this.core, this); } unRegisterInnerService() { this._attribute = undefined; this._unread = undefined; this._cloud = undefined; } get attribute() { if (this._attribute) { return this._attribute; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: 'V2NIMLocalConversationService attribute is unavailable' } }); } } get unread() { if (this._unread) { return this._unread; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: 'V2NIMLocalConversationService unread is unavailable' } }); } } get cloud() { if (this._cloud) { return this._cloud; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: 'V2NIMLocalConversationService cloud is unavailable' } }); } } async onLoginStart(accountId) { try { this.core.logger.info(e1, 'onLoginStart', accountId); this.registerInnerService(); await this.loadOnLogin(); } catch (e) { this.core.logger.error(e1, 'onLoginStart', e); } } async onLoginFinished(accountId) { this.core.logger.info(e1, 'onLoginFinished', accountId); } onLogout() { this.core.logger.info(e1, 'onLogout'); this.unRegisterInnerService(); } async loadOnLogin() { try { await this.unread.onDatabaseOpen(); } catch (e) { this.core.logger.error(e1, `loadOnLogin catch error`, e); const error = e; this.core.reporterService?.addException({ action: 6, code: error.code, description: error.message, operationType: 0, context: error.stack, target: `V2NIMLocalConversationServiceImpl loadOnLogin.` }); } return; } async getConversationList(offset, limit) { this.core.logger.info(e1, `call API getConversationList, offset: ${offset}, limit: ${limit}`); return await this.v2IGetConversationList(offset, limit); } async getConversationListByOption(offset, limit, option) { this.core.logger.info(e1, `call API getConversationListByOption, offset: ${offset}, limit: ${limit}`, 'option:', option); return await this.v2IGetConversationListByOption(offset, limit, option); } async getConversation(b31) { this.core.logger.info(e1, `call API getConversation, conversationId: ${b31}`); return await this.v2IGetConversation(b31); } async getConversationListByIds(a31) { this.core.logger.info(e1, 'call API getConversationListByIds, conversationIds', a31); return await this.v2IGetConversationListByIds(a31); } async createConversation(z30) { this.core.logger.info(e1, `call API createConversation, conversationId: ${z30}`); return await this.v2ICreateConversation(z30); } async deleteConversation(x30, y30) { this.core.logger.info(e1, `call API deleteConversation, conversationId: ${x30}, clearMessage: ${y30}`); return await this.v2IDeleteConversation(x30, y30); } async deleteConversationListByIds(v30, w30) { this.core.logger.info(e1, 'call API deleteConversationListByIds, conversationIds', v30, 'clearMessage:', w30); return await this.v2IDeleteConversationListByIds(v30, w30); } async stickTopConversation(t30, u30) { this.core.logger.info(e1, `call API stickTopConversation, conversationId: ${t30}, stickTop: ${u30}`); return await this.v2IStickTopConversation(t30, u30); } async updateConversation(r30, s30) { this.core.logger.info(e1, 'call API updateConversation, conversationId', r30, 'updateInfo:', s30); return await this.v2IUpdateConversation(r30, s30); } async updateConversationLocalExtension(p30, q30) { this.core.logger.info(e1, `call API updateConversationLocalExtension, conversationId: ${p30}, localExtension: ${q30}`); return await this.v2IUpdateConversationLocalExtension(p30, q30); } getTotalUnreadCount() { this.core.logger.info(e1, `call API getTotalUnreadCount`); return this.v2IGetTotalUnreadCount(); } getUnreadCountByIds(o30) { this.core.logger.info(e1, 'call API getUnreadCountByIds, conversationIds', o30); return this.v2IGetUnreadCountByIds(o30); } getUnreadCountByFilter(filter) { this.core.logger.info(e1, 'call API getUnreadCountByFilter, filter', filter); return this.v2IGetUnreadCountByFilter(filter); } async clearTotalUnreadCount() { this.core.logger.info(e1, `call API clearTotalUnreadCount`); return await this.v2IClearTotalUnreadCount(); } async clearUnreadCountByIds(n30) { this.core.logger.info(e1, 'call API clearUnreadCountByIds, conversationIds', n30); return await this.v2IClearUnreadCountByIds(n30); } async clearUnreadCountByTypes(types) { this.core.logger.info(e1, 'call API clearUnreadCountByTypes, types', types); return await this.v2IClearUnreadCountByTypes(types); } subscribeUnreadCountByFilter(filter) { this.core.logger.info(e1, 'call API subscribeUnreadCountByFilter, filter', filter); return this.v2ISubscribeUnreadCountByFilter(filter); } unsubscribeUnreadCountByFilter(filter) { this.core.logger.info(e1, 'call API unsubscribeUnreadCountByFilter, filter', filter); return this.v2IUnsubscribeUnreadCountByFilter(filter); } async markConversationRead(m30) { this.core.logger.info(e1, `call API markConversationRead, conversationId: ${m30}`); return await this.v2IMarkConversationRead(m30); } async getConversationReadTime(l30) { this.core.logger.info(e1, `call API getConversationReadTime, conversationId: ${l30}`); return await this.v2IGetConversationReadTime(l30); } async onMessageReceived(message) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/receiveMessage, message:', message); const j30 = await this.attribute.onMessageReceived(message); const k30 = await this.unread.onMessageReceived(message); await this.notifyConversation(j30, k30, message.conversationId); return; } async onMessageSent(message) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/sendMessage, message', message); const h30 = await this.attribute.onMessageSent(message); const i30 = await this.unread.onMessageSent(message); await this.notifyConversation(h30, i30, message.conversationId, message); return; } async onMessageInserted(message) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/insertMessage, message: ', message); const f30 = await this.attribute.onMessageInserted(message); const g30 = await this.unread.onMessageInserted(message); await this.notifyConversation(f30, g30, message.conversationId); return; } async onMessagesDeleted(c30) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/deleteMessages, deleteNotifications', c30); const d30 = await this.attribute.onMessagesDeleted(c30); const e30 = await this.unread.onMessagesDeleted(c30); await this.notifyMultiConversations(d30, e30); return; } async onMessagesRevoked(z29) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/revokeMessages, notifications', z29); const a30 = await this.attribute.onMessagesRevoked(z29); const b30 = await this.unread.onMessagesRevoked(z29); await this.notifyMultiConversations(a30, b30); return; } async onMessagesModify(w29) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/onMessagesModify, notifications', w29); const x29 = await this.attribute.onMessagesModify(w29); const y29 = await this.unread.onMessagesModify(w29); await this.notifyMultiConversations(x29, y29); return; } async onMessagesCleared(t29) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/clearMessages, clearNotifications', t29); const u29 = await this.attribute.onMessagesCleared(t29); const v29 = await this.unread.onMessagesCleared(t29); await this.notifyMultiConversations(u29, v29); return; } async onMessagesSynced(q29) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/syncMessages, messages', q29.length); const r29 = await this.attribute.onMessagesSynced(q29); const s29 = await this.unread.onMessagesSynced(q29); await this.notifyMultiConversations(r29, s29); return; } async onMessagesFetched(n29) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/fetchMessages, messages', n29); const o29 = await this.attribute.onMessagesFetched(n29); const p29 = await this.unread.onMessagesFetched(n29); await this.notifyMultiConversations(o29, p29); return; } async onConversationSetMute(k29, mute) { this.core.logger.info(e1, 'on V2NIMLocalConversationService/setMute, conversationId', k29, 'mute:', mute); const l29 = await this.attribute.onConversationSetMute(k29, mute); const m29 = await this.unread.onConversationSetMute(k29, mute); await this.notifyConversation(l29, m29, k29); return; } async observeMainSyncState(type, state, error) { if (type !== V2NIMDataSyncType.V2NIM_DATA_SYNC_TYPE_MAIN) { return; } switch (state) { case V2NIMDataSyncState.V2NIM_DATA_SYNC_STATE_SYNCING: this.core.logger.info(e1, `onSyncStarted`); this.emit('onSyncStarted'); break; case V2NIMDataSyncState.V2NIM_DATA_SYNC_STATE_COMPLETED: if (error) { this.core.logger.info(e1, `onSyncFailed, error:${error}`); this.emit('onSyncFailed', error); } else { this.core.logger.info(e1, `onSyncFinished`); this.emit('onSyncFinished'); } this.unread.notifyUnreadCountChangedAfterSyncCompleted(); break; default: break; } } async v2IGetConversationList(offset, limit) { try { validate({ offset: { type: 'number', min: 0 } }, { offset: offset }, '', true); validate({ limit: { type: 'number', min: 1 } }, { limit: limit }, '', true); const result = await this.attribute.getListByOption(offset, limit, {}); this.core.logger.info(e1, 'getConversationList', result); return result; } catch (e) { this.core.logger.error(e1, 'API getConversationList', e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getConversationList ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IGetConversationListByOption(offset, limit, option) { try { validate({ offset: { type: 'number', min: 0 }, limit: { type: 'number', min: 1 } }, { offset: offset, limit: limit }, '', true); validate({ limit: { type: 'number', min: 1 } }, { limit: limit }, '', true); validate({ option: { type: 'object', required: true, rules: { conversationTypes: { type: 'array', itemType: 'number', required: false }, onlyUnread: { type: 'boolean', required: false } } } }, { option: option }, '', true); const result = await this.attribute.getListByOption(offset, limit, option); this.core.logger.info(e1, 'getConversationListByOption', result); return result; } catch (e) { this.core.logger.error(e1, `API getConversationListByOption`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getConversationListByOption ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IGetConversation(i29) { try { validateConversationId(this.core.account, i29); const j29 = await this.attribute.getById(i29); if (typeof j29 !== 'undefined') { this.core.logger.info(e1, 'API getConversation:', j29); return j29; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST }); } } catch (e) { this.core.logger.error(e1, `API getConversation`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getConversation ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IGetConversationListByIds(h29) { try { validate({ i: { type: 'array', itemType: 'string', min: 1 } }, { i: h29 }, '', true); const result = await this.attribute.getByIds(h29); this.core.logger.info(e1, 'API getConversationListByIds', result); return result; } catch (e) { this.core.logger.error(e1, `API getConversationListByIds`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getConversationListByIds ${JSON.stringify(e)}`, rawError: e } }); } } } async v2ICreateConversation(f29) { try { validateConversationId(this.core.account, f29); const g29 = await this.attribute.create(f29); this.core.logger.info(e1, 'createConversation', g29); return g29; } catch (e) { this.core.logger.error(e1, `API createConversation`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `createConversation ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IDeleteConversation(d29, e29) { try { validateConversationId(this.core.account, d29); validate({ j: { type: 'boolean', required: false } }, { j: e29 }, '', true); await this.attribute.deleteById(d29); if (e29) { await this.core.messageService.v2IDeleteLocalMessageByConversation(d29); } return; } catch (e) { this.core.logger.error(e1, `API deleteConversation`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `deleteConversation ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IDeleteConversationListByIds(x28, y28) { try { validate({ i: { type: 'array', itemType: 'string', min: 1 } }, { i: x28 }, '', true); validate({ j: { type: 'boolean', required: false } }, { j: y28 }, '', true); const z28 = await this.attribute.deleteByIds(x28); const a29 = z28.map((result) => { return result.conversationId; }); const b29 = x28.filter((id) => { return !a29.includes(id); }); if (y28) { await Promise.all(b29.map(async (c29) => { await this.core.messageService.v2IDeleteLocalMessageByConversation(c29); })); } return z28; } catch (e) { this.core.logger.error(e1, `API deleteConversationListByIds`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `deleteConversationListByIds ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IStickTopConversation(u28, v28) { try { this.verifyLoginStatus(); validateConversationId(this.core.account, u28); validate({ stickTop: { type: 'boolean' } }, { stickTop: v28 }, '', true); const w28 = await this.attribute.getById(u28); if (typeof w28 === 'undefined') { this.core.logger.info(e1, `stickTop, but conversationId: ${u28} not exist`); throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_RESOURCE_NOT_EXIST, detail: { reason: `stickTop failed, conversation: ${u28} is not exist.` } }); } const updateTime = await this.cloud.stickTop(u28, v28); await this.attribute.stickTop(u28, v28, updateTime); await this.updateSyncStickTopTime(updateTime); } catch (e) { this.core.logger.error(e1, `API stickTopConversation`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `stickTopConversation ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IUpdateConversation(s28, t28) { try { validateConversationId(this.core.account, s28); return await this.attribute.update(s28, t28); } catch (e) { this.core.logger.error(e1, `API updateConversation`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `updateConversation ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IUpdateConversationLocalExtension(q28, r28) { try { validateConversationId(this.core.account, q28); validate({ localExtension: { type: 'string' } }, { localExtension: r28 }, '', true); return await this.attribute.updateLocalExtension(q28, r28); } catch (e) { this.core.logger.error(e1, `API updateConversationLocalExtension`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `updateConversationLocalExtension ${JSON.stringify(e)}`, rawError: e } }); } } } v2IGetTotalUnreadCount() { try { return this.unread.getTotal(); } catch (e) { this.core.logger.error(e1, 'getTotalUnreadCount', e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { const p28 = e; if (p28.code === V2NIMErrorCode.V2NIM_ERROR_CODE_ILLEGAL_STATE) { return 0; } else { throw e; } } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getTotalUnreadCount ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IGetUnreadCountByIds(o28) { try { validate({ i: { type: 'array', itemType: 'string', min: 1 } }, { i: o28 }, '', true); return this.unread.getByIds(o28); } catch (e) { this.core.logger.error(e1, `API getUnreadCountByIds`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getUnreadCountByIds ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IGetUnreadCountByFilter(filter) { try { this.validateFilter(filter); return this.unread.getByFilter(filter); } catch (e) { this.core.logger.error(e1, `API getUnreadCountByFilter`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getUnreadCountByFilter ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IClearTotalUnreadCount() { try { const result = await this.unread.clearTotal(); const k28 = result.unreadCacheEntities; const l28 = await this.attribute.getByIds(k28.map((n28) => n28.conversationId)); this.triggerOnConversationChanged(l28); const m28 = this.getAckTuplesFromEntities(k28); await this.cloud.markAck(m28); return; } catch (e) { this.core.logger.error(e1, `API clearTotalUnreadCount`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `clearTotalUnreadCount ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IClearUnreadCountByIds(e28) { try { validate({ i: { type: 'array', itemType: 'string', min: 1 } }, { i: e28 }, '', true); const result = await this.unread.clearByIds(e28); const f28 = result.operationResults; const g28 = result.unreadCacheEntities; const h28 = await this.attribute.getByIds(g28.map((j28) => j28.conversationId)); this.triggerOnConversationChanged(h28); const i28 = this.getAckTuplesFromEntities(g28); await this.cloud.markAck(i28); return f28; } catch (e) { this.core.logger.error(e1, `API clearUnreadCountByIds`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `clearUnreadCountByIds ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IClearUnreadCountByTypes(types) { try { validate({ types: { type: 'array', itemType: 'number', min: 1 } }, { types: types }, '', true); if (types.includes(V2NIMConversationType.V2NIM_CONVERSATION_TYPE_UNKNOWN)) { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, desc: `types cannot contain V2NIMConversationType.V2NIM_CONVERSATION_TYPE_UNKNOWN` }); } types.map((d28) => { if (d28 > V2NIMConversationType.V2NIM_CONVERSATION_TYPE_SUPER_TEAM || d28 < V2NIMConversationType.V2NIM_CONVERSATION_TYPE_P2P) { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, desc: `types not in V2NIMConversationType, invalid type: ${d28}` }); } }); const result = await this.unread.clearByTypes(types); const y27 = result.operationResults; const z27 = result.unreadCacheEntities; const a28 = await this.attribute.getByIds(z27.map((c28) => c28.conversationId)); this.triggerOnConversationChanged(a28); const b28 = this.getAckTuplesFromEntities(z27); await this.cloud.markAck(b28); return; } catch (e) { this.core.logger.error(e1, `API clearUnreadCountByTypes`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `clearUnreadCountByTypes ${JSON.stringify(e)}`, rawError: e } }); } } } v2ISubscribeUnreadCountByFilter(filter) { try { this.validateFilter(filter); this.unread.addFilter(filter); } catch (e) { this.core.logger.error(e1, `API subscribeUnreadCountByFilter`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `subscribeUnreadCountByFilter ${JSON.stringify(e)}`, rawError: e } }); } } } v2IUnsubscribeUnreadCountByFilter(filter) { try { this.validateFilter(filter); this.unread.deleteFilter(filter); } catch (e) { this.core.logger.error(e1, `API unsubscribeUnreadCountByFilter`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `unsubscribeUnreadCountByFilter ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IGetConversationReadTime(x27) { try { validateConversationId(this.core.account, x27); return await this.unread.getReadTimeById(x27); } catch (e) { this.core.logger.error(e1, `API getConversationReadTime`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `getConversationReadTime ${JSON.stringify(e)}`, rawError: e } }); } } } async v2IMarkConversationRead(r27) { try { validateConversationId(this.core.account, r27); const s27 = await this.attribute.getById(r27); if (typeof s27 === 'undefined') { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: 'markConversationRead, but conversation not exist' } }); } const result = await this.unread.clearByIds([r27]); const t27 = result.unreadCacheEntities; const u27 = await this.attribute.getByIds(t27.map((w27) => w27.conversationId)); this.triggerOnConversationChanged(u27); const v27 = this.getAckTuplesFromEntities(t27); await this.cloud.markAck(v27); return await this.unread.getReadTimeById(r27); } catch (e) { this.core.logger.error(e1, `API markConversationRead`, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_UNKNOWN, detail: { reason: `markConversationRead ${JSON.stringify(e)}`, rawError: e } }); } } } async notifyConversation(k27, l27, m27, n27) { const eventTypes = []; eventTypes.push(k27); eventTypes.push(l27 == NotifyEventType.CREATE_EVENT ? NotifyEventType.UPDATE_EVENT : l27); if (eventTypes.includes(NotifyEventType.CREATE_EVENT)) { const q27 = await this.attribute.getById(m27); if (q27) { this.triggerOnConversationCreated(q27); } } else if (eventTypes.includes(NotifyEventType.UPDATE_EVENT)) { const p27 = await this.attribute.getById(m27); if (n27) { this.resolveMismatchedMessages(n27, p27); } if (p27) { this.triggerOnConversationChanged([p27]); } } const o27 = eventTypes.map((type) => { const map = new HashMap(); map.set(m27, type); return map; }); } async notifyMultiConversations(c27, d27) { d27.forEach((value, key) => { if (value === NotifyEventType.CREATE_EVENT) { d27.set(key, NotifyEventType.UPDATE_EVENT); } }); const e27 = new HashSet(); const f27 = new HashSet(); for (const map of [c27, d27]) { for (const j27 of map.keys()) { switch (map.get(j27)) { case NotifyEventType.UPDATE_EVENT: if (!e27.has(j27)) { f27.add(j27); } break; case NotifyEventType.CREATE_EVENT: f27.remove(j27); e27.add(j27); break; default: break; } } } for (const h27 of e27.values()) { const i27 = await this.attribute.getById(h27); if (i27) { this.triggerOnConversationCreated(i27); } } if (f27.length > 0) { const g27 = await this.attribute.getByIds(Array.from(f27)); this.triggerOnConversationChanged(g27); } } resolveMismatchedMessages(z26, a27) { if (a27 && a27.lastMessage && z26.messageClientId === a27.lastMessage.messageRefer.messageClientId && a27.lastMessage.sendingState === V2NIMMessageSendingState.V2NIM_MESSAGE_SENDING_STATE_SENDING && z26.sendingState === V2NIMMessageSendingState.V2NIM_MESSAGE_SENDING_STATE_SUCCEEDED) { this.core.logger.warn(e1, `SendingState is mismatched between 'sentMessage' & 'changedConversation.lastMessage'`); a27.lastMessage.sendingState = z26.sendingState; a27.lastMessage.messageRefer.createTime = z26.createTime; a27.lastMessage.messageRefer.messageServerId = z26.messageServerId; this.attribute.getById(a27.conversationId) .then((b27) => { if (b27) { this.core.logger.warn(e1, `ResolveMismatchedMessages, conv: ${b27.conversationId}, ${JSON.stringify(b27)}`); } }); } } triggerOnConversationCreated(y26) { if (typeof y26 === 'undefined') { return; } this.core.logger.info(e1, 'notify created conversation', y26.conversationId, ':', y26); this.emit('onConversationCreated', y26); } triggerOnConversationDeleted(x26) { if (x26.length <= 0) { return; } this.core.logger.info(e1, 'notify deleted conversations', x26); this.emit('onConversationDeleted', x26); } triggerOnConversationChanged(w26) { if (w26.length <= 0) { return; } this.core.logger.info(e1, 'notify changed conversations', w26); this.emit('onConversationChanged', w26); } triggerOnTotalUnreadCountChanged(v26) { this.core.logger.info(e1, `notify total unread count changed: ${v26}`); this.emit('onTotalUnreadCountChanged', v26); } triggerOnUnreadCountChangedByFilter(filter, u26) { this.core.logger.info(e1, 'notify unread count changed by filter: unreadCount', u26, 'filter:', filter); this.emit('onUnreadCountChangedByFilter', filter, u26); } triggerOnConversationReadTimeUpdated(t26, timestamp) { this.core.logger.info(e1, 'notify read time updated conversation', t26, timestamp); this.emit('onConversationReadTimeUpdated', t26, timestamp); } async syncMarkSessionAckHandler(r26) { this.core.logger.info(e1, 'call Handler syncMarkSessionAckHandler'); const to = get(r26.content, 'to'); const scene = get(r26.content, 'scene'); const timestamp = get(r26.content, 'timetag'); const s26 = await this.cloud.processSyncMarkConversationAck(to, scene, timestamp); await this.updateSyncP2PTeamReadTime(timestamp); if (s26) { await this.notifyConversation(NotifyEventType.NO_EVENT, s26.eventType, s26.conversationId); } } async syncMarkSuperTeamSessionAckHandler(p26) { this.core.logger.info(e1, 'call Handler syncMarkSuperTeamSessionAckHandler'); const to = get(p26.content, 'to'); const timestamp = get(p26.content, 'timetag'); const q26 = await this.cloud.processSyncMarkConversationAck(to, SceneType.SUPER_TEAM, timestamp); await this.updateSyncSuperReadTime(timestamp); if (q26) { await this.notifyConversation(NotifyEventType.NO_EVENT, q26.eventType, q26.conversationId); } } async v2ISyncMultiMarkSessionAckHandler(i26, j26) { this.core.logger.info('SyncService', 'v2ISyncMultiMarkSessionAckHandler start'); const k26 = new HashMap(); const l26 = get(i26.content, 'p2p'); if (l26) { for (const to of Object.keys(l26)) { const timestamp = get(l26, to); const o26 = await this.cloud.processSyncMarkConversationAck(to, SceneType.P2P, timestamp); if (o26) { k26.set(o26.conversationId, o26.eventType); } } } const m26 = get(i26.content, 'team.m_map'); if (m26) { for (const to of Object.keys(m26)) { const timestamp = get(m26, to); const n26 = await this.cloud.processSyncMarkConversationAck(to, SceneType.TEAM, timestamp); if (n26) { k26.set(n26.conversationId, n26.eventType); } } } if (j26) { await this.updateSyncP2PTeamReadTime(get(i26.content, 'timetag')); } await this.notifyMultiConversations(new HashMap(), k26); this.core.logger.info('SyncService', 'v2ISyncMultiMarkSessionAckHandler end'); } async v2ISyncMultiMarkSuperTeamSessionAckHandler(d26, e26) { this.core.logger.info('SyncService', 'v2ISyncMultiMarkSuperTeamSessionAckHandler start'); const f26 = new HashMap(); const g26 = get(d26.content, 'superTeam.m_map'); if (g26) { for (const to of Object.keys(g26)) { const timestamp = get(g26, to); const h26 = await this.cloud.processSyncMarkConversationAck(to, SceneType.SUPER_TEAM, timestamp); if (h26) { f26.set(h26.conversationId, h26.eventType); } } } if (e26) { await this.updateSyncSuperReadTime(get(d26.content, 'timetag')); } await this.notifyMultiConversations(new HashMap(), f26); this.core.logger.info('SyncService', 'v2ISyncMultiMarkSuperTeamSessionAckHandler end'); } async nimMultiSyncAddStickTopSessionHandler(z25) { this.core.logger.info(e1, 'call Handler nimMultiSyncAddStickTopSessionHandler'); const id = get(z25.content, 'data.id'); const a26 = get(z25.content, 'data.updateTime'); const b26 = getConversationIdFomCloud(id, this.core); const c26 = new StickTopInfo(b26, a26, true); await this.cloud.processSyncStickTop(c26); await this.updateSyncStickTopTime(a26); } async nimMultiSyncDeleteStickTopSessionHandler(v25) { this.core.logger.info(e1, 'call Handler nimMultiSyncDeleteStickTopSessionHandler'); const id = get(v25.content, 'data.id'); const w25 = get(v25.content, 'timetag'); const x25 = getConversationIdFomCloud(id, this.core); const y25 = new StickTopInfo(x25, w25, false); await this.cloud.processSyncStickTop(y25); await this.updateSyncStickTopTime(w25); } async v2ISyncStickTopSessionsHandler(i25, j25) { this.core.logger.info('SyncService', 'v2ISyncStickTopSessionsHandler start'); const k25 = get(i25.content, 'timetag'); const l25 = get(i25.content, 'isThereAnyChange'); if (!l25) { } else { const m25 = get(i25.content, 'datas'); this.core.logger.info(e1, 'nimSyncStickTopSessionsHandler, datas', m25); const n25 = m25.map((data) => { const id = get(data, 'id'); const t25 = get(data, 'updateTime'); const u25 = getConversationIdFomCloud(id, this.core); return new StickTopInfo(u25, t25, true); }); const o25 = await this.attribute.queryAllStickTopTimeIds(); const p25 = n25.map((info) => info.conversationId); const q25 = []; o25.map((r25) => { if (!p25.includes(r25)) { const s25 = k25; q25.push(new StickTopInfo(r25, s25, false)); } }); await this.cloud.processSyncStickTopBatch(n25); await this.cloud.processSyncStickTopBatch(q25); await this.attribute.deleteStickTopTimeNotIn(p25); } if (j25) { await this.updateSyncStickTopTime(k25); } this.core.logger.info('SyncService', 'v2ISyncStickTopSessionsHandler end'); } getAckTuplesFromEntities(f25) { const g25 = []; f25.map(h25 => { g25.push(new MarkConvAckTuple(h25.conversationId, this.core.conversationIdUtil.parseConversationType(h25.conversationId), h25.timestamp)); }); return g25; } async updateSyncP2PTeamReadTime(time) { await this.core.syncService.updateSyncTimestamp2(time, 'sessionAck'); } async updateSyncSuperReadTime(time) { await this.core.syncService.updateSyncTimestamp2(time, 'superTeamSessionAck'); } async updateSyncStickTopTime(time) { if (typeof time === 'string') { time = Number.parseInt(time); } await this.core.syncService.updateSyncTimestamp2(time + 1, 'stickTopSessions'); } validateFilter(filter) { validate({ filter: { type: 'object', required: true, rules: { conversationTypes: { type: 'array', itemType: 'number', min: 0, required: false }, ignoreMuted: { type: 'boolean', required: false } } } }, { filter: filter }, '', true); if (filter.conversationTypes?.length === 0) { filter.conversationTypes = undefined; } if (typeof filter.conversationTypes === 'undefined' && filter.ignoreMuted !== true) { throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_INVALID_PARAMETER, detail: { reason: 'Filter cannot be empty' } }); } } verifyLoginStatus() { const e25 = this.core.loginService.getLoginStatus(); if (e25 !== V2NIMLoginStatus.V2NIM_LOGIN_STATUS_LOGINED) { this.logger.warn(`NIM login status is ${e25}, block`); throw new V2NIMErrorImpl({ code: V2NIMErrorCode.V2NIM_ERROR_CODE_ILLEGAL_STATE, detail: { reason: 'Blocked due to not logged in' } }); } } } 