import { RdbPredicates, V2NIMErrorImpl, V2NIMErrorMap } from '@nimsdk/base'; import { V2NIMLocalConversationImpl } from '../impl/V2NIMLocalConversationImpl'; import { registerAspect } from './Aspect'; import { V2NIMLocalConversationStatus } from '../utils/types'; import { AbsLocalConversationTable } from './AbsLocalConversationTable'; import { TABLE_LOCAL_CONVERSATION } from './types'; const e1 = '[LocalConversationAttributeTable]'; export class LocalConversationAttributeTable extends AbsLocalConversationTable { constructor(s1, t1) { super(s1); this.logger = t1.logger; registerAspect(this.tableName, LocalConversationAttributeTable, t1); } async query(limit, offset, option) { try { await this.ensureCreateTable(); this.logger.info(e1, 'query', limit, offset, option); const predicates = new RdbPredicates(this.tableName); predicates .notEqualTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.STATUS, V2NIMLocalConversationStatus.DELETED) .limitAs(limit) .orderByDesc(TABLE_LOCAL_CONVERSATION.COL_ENUM.SORT_ORDER); if (offset > 0) { predicates .and() .lessThan(TABLE_LOCAL_CONVERSATION.COL_ENUM.SORT_ORDER, offset); } if (typeof option.conversationTypes !== 'undefined' && option.conversationTypes.length > 0) { predicates .and() .in(TABLE_LOCAL_CONVERSATION.COL_ENUM.TYPE, option.conversationTypes); } if (option.onlyUnread === true) { predicates .and() .greaterThan(TABLE_LOCAL_CONVERSATION.COL_ENUM.UNREAD_COUNT, 0); } const values = await this.rdbStoreManager.query(predicates); const q1 = []; values.map((v) => { q1.push(V2NIMLocalConversationImpl.buildFromValueBucket(v)); }); return q1; } catch (e) { this.logger.error(e1, 'query', limit, offset, option, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation query, limit: ${limit}, offset: ${offset}, option: ${option}`, rawError: e } }); } } } async queryById(o1) { try { await this.ensureCreateTable(); this.logger.info(e1, 'queryById', o1); const predicates = new RdbPredicates(this.tableName); predicates .equalTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, o1) .and() .notEqualTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.STATUS, V2NIMLocalConversationStatus.DELETED); const values = await this.rdbStoreManager.query(predicates); if (values.length > 0) { const p1 = V2NIMLocalConversationImpl.buildFromValueBucket(values[0]); return p1; } else { return undefined; } } catch (e) { this.logger.error(e1, 'queryById', o1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation queryById ${o1}`, rawError: e } }); } } } async queryByIds(m1) { try { await this.ensureCreateTable(); this.logger.info(e1, 'queryByIds', m1); if (!m1 || m1.length <= 0) { return []; } let predicates = new RdbPredicates(this.tableName); predicates .in(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, m1) .and() .notEqualTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.STATUS, V2NIMLocalConversationStatus.DELETED); const values = await this.rdbStoreManager.query(predicates); const n1 = []; values.map((v) => { n1.push(V2NIMLocalConversationImpl.buildFromValueBucket(v)); }); return n1; } catch (e) { this.logger.error(e1, 'queryByIds', m1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation queryByIds ${m1}`, rawError: e } }); } } } async insert(l1) { try { await this.ensureCreateTable(); this.logger.info(e1, 'insert', l1); if (typeof l1 === 'undefined') { this.logger.info(e1, `insert conversation is undefined`); return; } const valueBucket = l1.generateBucket(); await this.rdbStoreManager.insertOrReplace(this.tableName, [valueBucket]); } catch (e) { this.logger.error(e1, 'insert', l1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation insert ${JSON.stringify(l1)}`, rawError: e } }); } } } async update(j1) { try { await this.ensureCreateTable(); this.logger.info(e1, 'update', j1); const predicates = new RdbPredicates(this.tableName); predicates .equalTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, j1.conversationId); const valueBucket = V2NIMLocalConversationImpl.generateUpdateBucket(j1); const k1 = await this.rdbStoreManager.update(valueBucket, predicates); return k1; } catch (e) { this.logger.error(e1, 'update', j1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation update ${JSON.stringify(j1)}`, rawError: e } }); } } } async delete(i1) { try { await this.ensureCreateTable(); this.logger.info(e1, 'delete', i1); const predicates = new RdbPredicates(this.tableName); predicates.equalTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, i1); return await this.rdbStoreManager.delete(predicates); } catch (e) { this.logger.error(e1, 'delete', i1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation delete, conv: ${i1}`, rawError: e } }); } } } async deleteBatch(h1) { try { if (!h1 || h1.length <= 0) { return 0; } await this.ensureCreateTable(); this.logger.info(e1, 'deleteBatch', h1); const predicates = new RdbPredicates(this.tableName) .in(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, h1); return await this.rdbStoreManager.delete(predicates); } catch (e) { this.logger.error(e1, 'deleteBatch', h1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation deleteBatch, convs: ${JSON.stringify(h1)}`, rawError: e } }); } } } async softDelete(g1) { try { await this.ensureCreateTable(); this.logger.info(e1, 'softDelete', g1); const predicates = new RdbPredicates(this.tableName) .equalTo(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, g1); let valueBucket = {}; valueBucket[TABLE_LOCAL_CONVERSATION.COL_ENUM.STATUS] = V2NIMLocalConversationStatus.DELETED; return await this.rdbStoreManager.update(valueBucket, predicates); } catch (e) { this.logger.error(e1, 'softDelete', g1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation delete, conv: ${g1}`, rawError: e } }); } } } async softDeleteBatch(f1) { try { if (!f1 || f1.length <= 0) { return 0; } await this.ensureCreateTable(); this.logger.info(e1, 'softDeleteBatch', f1); const predicates = new RdbPredicates(this.tableName) .in(TABLE_LOCAL_CONVERSATION.COL_ENUM.CONVERSATION_ID, f1); let valueBucket = {}; valueBucket[TABLE_LOCAL_CONVERSATION.COL_ENUM.STATUS] = V2NIMLocalConversationStatus.DELETED; return await this.rdbStoreManager.update(valueBucket, predicates); } catch (e) { this.logger.error(e1, 'softDeleteBatch', f1, e); if (e instanceof V2NIMErrorImpl || e.name === 'V2NIMError') { throw e; } else { throw new V2NIMErrorImpl({ code: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.code, desc: V2NIMErrorMap.V2NIM_ERROR_CODE_UNKNOWN.message, detail: { reason: `local conversation deleteBatch, convs: ${JSON.stringify(f1)}`, rawError: e } }); } } } } 